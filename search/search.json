[
 {
  "url": "/webinars/202005-001/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202006-002/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202006-003/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202006-004/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202006-005/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202006-006/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202006-007/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202006-008/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202006-009/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202007-001/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202007-005/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202007-006/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202007-007/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202007-008/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202007-009/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202007-010/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202007-011/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202007-012/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202007-013/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202008-001/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202008-002/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/libs/javascript/Advanced-usage/",
  "title": "RNS JS Library - Advanced Usage",
  "category": "",
  "tags": "rns, javascript",
  "date": "",
  "desc": "Instantiate the lib with your local blockchain The library has already set the contract addresses for RSK Mainnet and Testnet, so if the Web3 instance points to one of those networks, no extra action is needed. If you want to use your local blockchain, contract addresses must be provided and should be sent as parameter. If a custom blockchain has been set but the contracts addresses are not provided, it will throw “No contract addresses provided” on the first operation invoked. Example async function myCustomGetOwner(domain) { const web3 = new Web3(&#39;http://localhost:7545&#39;); const options = { contractAddresses: { registry: &#39;0x0000000000000000000000000000000123456789&#39; } }; const rns = new RNS(web3, options); const address = await rns.addr(&#39;testing.rsk&#39;); } You can also specify a different networkId to perform checksum validations according to EIP-1191, it should be added in the options…"
 },
 {
  "url": "/rif/rns/libs/Android/",
  "title": "Android Library",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Android Library to resolve your RIF Name Service address on your app. Import into your app Method 1: Import the AAR. You can go to our release page, and download the release. Here you have the AAR to import into your project, including the debug lib to use it. Method 2: Clone the project. user@computer:~/some/path/$ git clone git@github.com:rnsdomamins/RNS-SDK-android.git Cloning into &#39;RNS-SDK-android&#39;... user@computer:~/some/path/$ git checkout &amp;lt;INSERT_RELEASE_TAG_HERE&amp;gt; Import using AndroidStudio File -&amp;gt; New -&amp;gt; Import Module… With either of those methods methods You will have to add this lines to your build.gradle file, or do it in your Project Settings ( CTRL+ALT+SHIFT+S ) and set sourceCompatibility to 1.8: android { compileOptions { sourceCompatibility 1.8 targetCompatibility 1.8 } } How to use You will need access to a running rsk node that can made calls to the JSON-RPC. For this we have our public nodes available for you, that are already configured in our build.gradle file. You can change this or use the constructors for the resolver that will be described below. …"
 },
 {
  "url": "/rif/rns/libs/javascript/Contribute/",
  "title": "RNS JS Library - Contribute",
  "category": "",
  "tags": "rns, javascript",
  "date": "",
  "desc": "Run for development Install dependencies: git clone git@github.com:rnsdomains/rns-js.git cd rns-js npm i Run tests: npm test Try out your development Create a test project # in rns-js folder npm run build npm link cd .. mkdir rns-js-test cd rns-js-test npm init npm i web3 npm link @rsksmart/rns Create a new .js file, instantiate the library and try out your development. Versioning master branch points to the latest release. develop branch contains changes that will apply next release. The first commit after release bumps to next version. Other branches (feature branches) point to develop. Find release scopes in milestones."
 },
 {
  "url": "/rif/rns/architecture/Deed/",
  "title": "Deed",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ":warning: Deprecated. Find new registrar here. The Deed contract has two main features: Store RIF tokens locked on a bid Handle the annual rent payment. Deed contract holds RIF tokens in exchange for a domain ownership. The Deed contract is controlled by the Registrar and is the only one capable to sends tokens back to the owner. ABI: DeedABI.json Submitting a bid creates a Deed contract which holds the funds and stores information related to the owner and the domain expiration. Have a look at the Registrar bid submission: // Creates a new hash contract with the owner TokenDeed createdBid = new TokenDeed(_from, _tokenQuantity, tokenContract); require(tokenContract.transfer(createdBid, _tokenQuantity)); sealedBids[_from][_sealedBid] = createdBid; Once bidded, you can query for a particular bid’s Deed: var deedAddress = registrar.sealedBids(address, sealedBid) var deedInstante = web3.contract(deedAbi)…"
 },
 {
  "url": "/rif/rns/libs/javascript/Errors/",
  "title": "RNS JS Library - Error knowledge base",
  "category": "",
  "tags": "rns, javascript, error",
  "date": "",
  "desc": "Handle errors with RNS library RNS Library extends the Error class with two extra properties: id - The knowledge base ID ref - A link to the specific error within this page KB000 Message: Unknown error. Description: Unknown error. KB001 Message: No addr resolution set Description: The given domain has a resolver, but the resolution has not been set KB002 Message: No addr resolution Description: The given domain has a resolver, but it does not support addr interface KB003 Message: No resolver Description: The given domain doesn’t have a resolver set KB004 Message: Library not composed Description: Thrown when trying to accesses rns.contracts before executing rns.compose() KB005 Message: No contract addresses provided Description: Thrown when constructing lib on a local/custom RNS environment and contract addresses are not provided KB006 Message: No chain address resolution Description: The given domain has a resolver, but the resolution for the given chain has not been set KB007 Message: No chain address resolution set Description: The given domain has a resolver, but it does not support chainAddr interface …"
 },
 {
  "url": "/rif/rns/libs/javascript/Getting-started/",
  "title": "RNS JS Library - Getting Started",
  "category": "",
  "tags": "rns, javascript",
  "date": "",
  "desc": "Installation npm i web3 @rsksmart/rns Source code: github.com/rnsdomains/rns-js npm: npmjs.com/package/@rsksmart/rns Or just use it directly in your webpage: &amp;lt;script src=&quot;https://unpkg.com/web3@1.2.6/dist/web3.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&quot;https://unpkg.com/@rsksmart/rns@1.5.11/lib/rns.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt; Don’t forget to specify the desired version of the package! Basic usage import Web3 from &#39;web3&#39; import RNS from &#39;@rsksmart/rns&#39; import { ChainId } from &#39;@rsksmart/rns/types&#39; const web3 = new Web3(&#39;https://public-node.rsk.co&#39;) const rns = new RNS(web3) Remember that if you are running the code in a webpage, no import statements are needed, just instantiate the libs made available in the global scope. Find instructions in the advanced usage section if running local or custom blockchains. Get an address: rns.addr(&#39;testing.rsk&#39;).then(console.log) Get Bitcoin address: rns.addr(&#39;testing.rsk&#39;&amp;lt;span…"
 },
 {
  "url": "/develop/apps/tools/Introduction/",
  "title": "Libraries &amp; Tools",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Introduction Overview RSKj is the JavaScript Library within the RSK Foundation. Work is mainly done within the following GitHub organization: https://github.com/rsksmart There are currently over 20 active repositories, most (with some exceptions like keythereum &amp;lt;https://github.com/ethereumjs/keythereum&amp;gt;_ or ethrpc &amp;lt;https://github.com/ethereumjs/ethrpc&amp;gt;) managed by the EF team. Some central libraries are an implementation of the Ethereum Virtual Machine &amp;lt;https://github.com/ethereumjs/ethereumjs-vm&amp;gt;, our Client &amp;lt;https://github.com/ethereumjs/ethereumjs-client&amp;gt;_ project and implementations of the Merkle Patricia Tree &amp;lt;https://github.com/ethereumjs/merkle-patricia-tree&amp;gt;_ data structure or the devp2p &amp;lt;https://github.com/ethereumjs/ethereumjs-devp2p&amp;gt;_ networking stack. Have a look at the overview page linked above to get an impression what is currently being worked on as well as other libraries available. Focus and related Projects Main focus of EthereumJS is to provide high-quality and robust implementations of core Ethereum infrastructure technologies (virtual machine), protocols (devp2p) and data structures (merkle tree). Other related projects you might want to check out as well are e.g.: web3.js &amp;lt;https://github.com/ethereum/web3.js/&amp;gt;_ (Ethereum JavaScript API) ethers.js &amp;lt;https://github.com/ethers-io/ethers.js&amp;gt;_ (Ethereum Wallet implementation and library) Truffle &amp;lt;https://github.com/trufflesuite&amp;gt;_ (Development Framework) embark &amp;lt;https://github.com/embark-framework/embark&amp;gt;_ (dApp Framework) Remix &amp;lt;https://github.com/ethereum/remix&amp;gt;_ (https://github.com/ethereum/remix) Most of the projects above also make use of some of our base-layer…"
 },
 {
  "url": "/rif/rns/architecture/MultiCryptoResolver/",
  "title": "Multi-Crypto Resolver",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Multi-Crypto Resolver In the RNS registry we have launched a resolver capable of resolve addresses from other blockchains using a chain id as an identifier. With the same restrictions and visibility as the Public Resolver. This resolver implements all the methods described in the resolver specification Mainnet information Multi-Crypto Resolver Adrress: 0x99a12be4C89CbF6CFD11d1F2c029904a7B644368 ABI: MultiCryptoResolverABI.json See RNS Testnet section for testing environment information. Index Methods content setContent chainAddr setChainAddr chainMetadata setChainMetadata setChainAddrWithMetadata Events ChainAddrChanged Context AbstractRNS rns; rns: the Registry contract Storage mapping(bytes32=&amp;gt;address) addresses; mapping(bytes32=&amp;gt;bytes32) hashes; adresses: for each namehash entry, stores an address hashes: for each namehash entry, stores a hash Methods content Returns the content hash associated with an RNS node. Note that this resource type is not standardized, and will…"
 },
 {
  "url": "/rif/rns/tools/MyCrypto/",
  "title": "MyCrypto",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "MyCrypto is an open-source, client-side tool for generating ether wallets, handling ERC-20 tokens, and interacting with the blockchain more easily. There are two platforms to access MyCrypto, both with almost the same functionalities: the web app and the desktop app. There are more ways to access a wallet via desktop app, for example using a mnemonic or a private key. MyCrypto has a Contracts tab, where you can find some existing contracts loads, and other contracts can be instanced. We are going to use this functionality to get a domain on RNS registry. There are two ways to access a contract: If the contract is listed, just select it and access to it Otherwise you may need the contract address and the ABI (interface), which is given [here] for all mentioned contracts. Register a domain A domain is composed by a label and the .rsk suffix (top level domain). For example: nakamoto.rsk, where nakamoto is the label. When sha3 or namehash evaluations are asked, go here to interact with the tools and get the requested value. When sha3 is asked for a label, you should not evaluate it with .rsk suffix.…"
 },
 {
  "url": "/rif/rns/architecture/NameResolver/",
  "title": "Name Resolver",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Return a valid RNS name for the requested node, or the empty string if no name is defined for the requested node. Mainnet Address: 0x4b1a11bf6723e60b9d2e02aa3ece34e24bde77d9 ABI: NameResolverABI.json See RNS Testnet section for testing environment information. Index Methods setName name Methods setName Sets the name associated with an RNS node, for reverse records. May only be called by the owner of that node in the RNS registry. Signature function setName(bytes32 node, string calldata name) external Parameters node: the node to update. name: the name to set. Events event NameChanged(bytes32 node, string name); name Returns the name associated with an RNS node, for reverse records. Signature function name(bytes32 node) external view returns (string memory) Parameters node: the node to query. Events event NameChanged(bytes32 node, string name); Returns the associated name."
 },
 {
  "url": "/rif/rns/libs/javascript/Operations/",
  "title": "RNS JS Library - Operations",
  "category": "",
  "tags": "rns, javascript",
  "date": "",
  "desc": "Available operations addr setAddr contenthash setContenthash reverse setReverse setResolver available (for domains) subdomains.available subdomains.setOwner subdomains.create utils addr Get the address of a given domain and chain. If chainId is not provided, it resolves current blockchain address. Signature async addr(domain: string, chainId?: ChainId): Promise&amp;lt;string&amp;gt; Parameters domain: Domain to be resolved. chainId: Chain identifier listed in SLIP44 Returns string: the address resolution Throws KB001 KB002 KB003 KB006 KB007 Examples Get an address: rns.addr(&#39;testing.rsk&#39;).then(console.log) Get Bitcoin address: rns.addr(&#39;testing.rsk&#39;, ChainId.BITCOIN).then(console.log) setAddr Set the address of a given domain and chain.…"
 },
 {
  "url": "/rif/rns/libs/Python/",
  "title": "Python Library",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Python Library to resolve your RIF Name Service address on your app. Requirements Python Version: 3.7 Pip Version: lastest VirtualEnv Version: lastest Testing To run unit tests, clone this repository. Run Rsk Node and deploy resolver contracts. Check constants folder to specify, RPC_CLIENT_URL in client_constants.py file and RNS_RESOLVER_ADDRESS in rns_constants.py file. Add the PYTHONPATH environment variable of your operating system to the path of the folder where you cloned the project, this will allow the tests to directly invoke the file by console. Run: pip install virtualenv virtualenv -p /yourLocalPythonPath/python3.7 rns_sdk_py_env source rns_sdk_py_env/bin/activate pip install -r requirements.txt python setup.py develop python3.7 tests/units/test_resolver_contract.py -v The result that you should see if everything went well is test_addr (__main__.TestResolverConctract) ... ok test_addr_not_set (__main__.TestResolverConctract) ... ok test_has_other_kind (__main__.TestResolverConctract) ... ok test_set_addr (__main__.TestResolverConctract) ... ok test_set_content (__main__.TestResolverConctract) ... ok test_supports_interface (__main__.TestResolverConctract) ... ok test_unsupports_interface (__main__.TestResolverConctract) ... ok ---------------------------------------------------------------------- Ran 7 tests in 1.043s OK Usage and Getting Started In a Python console: from rns_sdk.resolver_contract import ResolverContract resolver…"
 },
 {
  "url": "/rif/rns/tools/RNS-Manager/",
  "title": "RNS Manager",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "The RNS Manager is a simple tool that interacts with RNS Smart Contracts via Metamask. It has the following methods: Manage auction with Registrar contract Check domain status with entries Start an auction with startAuction ERC-677 Make a bid with shaBid and newBid Reveal a bid with unsealBid Finalize an auction with finalizeAuction Manage rent payment with Deed contract Check rent status with owner, tokenQuantity, expirationDate and canPayRent Pay the rent with payRent ERC-677 Manage domain ownership with Registry contract Manage owner Manage resolver Manage TTL Manage sub nodes Manage domain resolutions with Resolver contract implementing addr field Resolve a name with addr Change address resolution with setAddr For further information go to the site. This project is open source: fork and PR!"
 },
 {
  "url": "/rif/rns/libs/javascript/RNS-instance/",
  "title": "RNS JS Library - Instance",
  "category": "",
  "tags": "rns, javascript",
  "date": "",
  "desc": "Installation npm i web3 @rsksmart/rns Source code: github.com/rnsdomains/rns-js npm: npmjs.com/package/@rsksmart/rns Or just use it directly in your webpage: &amp;lt;script src=&quot;https://unpkg.com/web3@1.2.6/dist/web3.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&quot;https://unpkg.com/@rsksmart/rns@1.5.11/lib/rns.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt; Don’t forget to specify the desired version of the package! Instance for queries to RSK Mainnet/Testnet import Web3 from &#39;web3&#39; import RNS from &#39;@rsksmart/rns&#39; const web3 = new Web3(&#39;https://public-node.rsk.co&#39;) // or &#39;https://public-node.testnet.rsk.co&#39; const rns = new RNS(web3) Remember that if you are running the code in a webpage, no import statements are needed, just instantiate the libs made available in the global scope. Instance in Chrome with wallet extension (Metamask or Nifty) import Web3 from &#39;web3&#39; import RNS from &#39;@rsksmart/rns&#39; if (!window.web3) { throw new Error(&#39;No wallet installed&#39;) }…"
 },
 {
  "url": "/rif/rns/architecture/RSKResolver/",
  "title": "RSK Resolver",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Along the RNS registry and initial registrar there is a public resolver deployed as well (see the RSKResolver contract). This contract is available for anybody to use it, but the only restriction is that only owners of a domain can modify its record in this resolver. This resolver implements all the methods described in the Resolver specification Additionally, it is used as the default resolver configured for new nodes created in the registry. There is an upgraded version of this resolver. See Multi-crypto resolver page. To migrate your resolver, execute the setResolver command on the registry. Mainnet information RSKResolver Adrress: 0x4efd25e3d348f8f25a14fb7655fba6f72edfe93a ABI: RSKResolverABI.json See RNS Testnet section for testing environment information. Index Methods has content setContent Context AbstractRNS rns; rns: the Registry contract Storage mapping(bytes32=&amp;gt;address) addresses; mapping(bytes32=&amp;gt;bytes32) hashes; adresses: for each namehash entry, stores an address hashes:…"
 },
 {
  "url": "/rif/rns/architecture/Registrar/",
  "title": "Registrar",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ":warning: Deprecated. Find new registrar here. The Registrar is the contract that handles the domain issuing logic. In this section we’ll explain the interaction with this contract. As explained in the RNS specification doc, the domain ownership is determinate by a Vickrey auction. A Vickrey auction is a type of sealed-bid auction. Bidders submit bids without knowing the bided amount of any other participant. The highest bidder is the winner and the price paid is the second-highest bid. Is RNS, the auction lasts 5 days and is divided in two periods: Auction phase: the first 3 days to bid for a specific domain. Reveal phase: the next 2 days for revealing the bids. There is no “soft start” phase, meaning that all names are available on launch time. Registrar mainnet Address: 0x5269f5bc51cdd8aa62755c97229b7eeddd8e69a6 ABI: RegistrarABI.json See RNS Testnet section for testing environment information. Index The process Rent and domain expiration Structure Methods startAuction startAuctions newBid newBidWithToken startAuctionsAndBid unsealBid finalizeAuction payRent &amp;lt;a…"
 },
 {
  "url": "/rif/rns/architecture/Resolver/",
  "title": "Resolver",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "The Resolver contract handles the resolution between the name domain and the resource. Each Registry entry references a Resolver. Use one of our resolvers, the Multi-Crypto Resolver, or the RSK Resolver. Index Structure Methods supportsinterface addr setAddr Events AddrChanged Structure Context AbstractRNS rns; rns: the Registry contract Storage mapping(bytes32=&amp;gt;address) addresses; mapping(bytes32=&amp;gt;bytes32) hashes; adresses: for each namehash entry, stores an address hashes: for each namehash entry, stores a hash Methods supportsInterface Returns true if the resolver implements the interface specified by the provided hash. This Resolver supports 0x3b3b57de = sha3(addr(bytes32)) 0xd8389dc5 = sha3(content(bytes32)) Signature function supportsInterface(bytes4 interfaceID) public pure returns (bool) Parameters interfaceID: the ID of the interface to check…"
 },
 {
  "url": "/rif/rns/architecture/ReverseRegistrar/",
  "title": "Reverse Registrar",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "The owner of the addr.reverse domain is a registrar that permits the caller to take ownership of the reverse record for their own address. Mainnet Address: 0xd25c3f94a743b93ecffecbe691beea51c3c2d9d1 ABI: ReverseRegistrarABI.json See RNS Testnet section for testing environment information. Index Methods setName claim claimWithResolver node Methods setName Sets the name record on that name to the specified name. Sets the resolver for the name hex(msg.sender).addr.reverse to a default resolver. Signature function setName(string memory name) public returns (bytes32 node) Parameters name: the name to set for this address. Returns the RNS node hash of the reverse record. claim Transfer ownership of the name hex(msg.sender).addr.reverse. Allows the caller to specify an owner other than themselves. The resulting account has name() resolver. Signature function claim(address owner) public returns (bytes32 node) Parameters owner: the address to set as the owner of the reverse record in RNS. Returns the RNS node hash of the reverse record. claimWithResolver Sets the resolver of the name &amp;lt;code…"
 },
 {
  "url": "/rif/rns/architecture/ReverseSuite/",
  "title": "Reverse suite",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Reverse RNS records are stored in the RNS hierarchy in the same fashion as regular records, under a reserved domain, addr.reverse. Compatible with EIP-181. Reverse resolving To generate the RNS name for a given account’s reverse records, convert the account to hexadecimal representation in lower-case, and append addr.reverse. For instance, the RNS registry’s address at 0x112234455c3a32fd11230c42e7bccd4a84e02010 has any reverse records stored at 112234455c3a32fd11230c42e7bccd4a84e02010.addr.reverse. function reverseResolve (address) { const reverseName = `${address.slice(2).toLowerCase}.addr.reverse`; const node = namehash(reverseName); const resolver = rns.resolver(node); const name = resolver.name(node); return name; } Ensure a reverse lookup As the owner of the reverse-node is able to set any name as resolution after claiming, it is important to ensure the resulting `name` is used in the forward-resolution. To do so you might query the name&#39;s address resolution.…"
 },
 {
  "url": "/rif/rns/tools/Subdomain-tool/",
  "title": "RNS Manager",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "It’s a sample DApp that could be seen as a component to facilitate the adoption of RNS. Find rns-subdomain-tool and run your standalone app! It shows 2 action flows: Register an alias: invite a final user to register his subdomain under a given domain. Check subdomain status: it will allow the user to check if an alias/subdomain is available or not. :incoming_envelope: You can set the tool up to send an email with a template to the user confirming the registration. :information_source: Also the tool will save information about registrations in a Mongo DB. :raised_hand: This tool includes an option to set up a maximum number of contract calls per hour."
 },
 {
  "url": "/rif/rns/libs/javascript/Utils/",
  "title": "RNS JS Library - Utils",
  "category": "",
  "tags": "rns, javascript",
  "date": "",
  "desc": "Available methods isValidDomain isValidLabel isValidTld hasMethod hasAccounts namehash labelhash isValidDomain Validates the given domain syntax. It allows dots and alphanumeric lowercase characters. Signature isValidDomain(domain:string): boolean; Parameters domain: Domain to be validated. Returns bool: true if valid, false if not Examples Valid domain: rns.utils.isValidDomain(&#39;testing123.rsk&#39;).then(console.log) Invalid domain: rns.utils.isValidDomain(&#39;nOtVali-d.rsk&#39;).then(console.log) isValidLabel Validates the given label syntax. It allows alphanumeric lowercase characters. Signature isValidLabel(label:string): boolean; Parameters label: Label to be validated. Returns bool: true if valid, false if not Examples Valid label: rns.utils.isValidLabel(&#39;testing123&#39;).then(console.log) …"
 },
 {
  "url": "/rif/rns/tools/Web3/",
  "title": "Web3",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "To use web3 and interact with the contracts, we must instance web3 with a provider. To do so we can use RSK public nodes: var Web3 = require(&#39;web3&#39;) var web3 = new Web3() web3.setProvider(new web3.providers.HttpProvider(config.node)) RNS Registry Instance the RNS Registry contract: const rnsAbi = [] const rnsAddress = &#39;&#39; var rnsInstance = web3.eth.contract(rnsAbi) var rns = registryInstance.at(rnsAddress) And include namehash library: var namehash = require(&#39;eth-ens-namehash&#39;).hash domain field does include .rsk suffix Further reading: RNS Registry contract. Change the resolver function setResolver(domain, newResolver) { var hash = namehash(domain) &amp;lt;span…"
 },
 {
  "url": "/rif/rns/guide/advanced/",
  "title": "Advanced operations - RNS User guide",
  "category": "",
  "tags": "rns, guide, rns-user-guide",
  "date": "",
  "desc": "How to change the controller of the domain, change the resolver of the domain, add a record, update a record, remove a record, enable reverse resolution lookups, disable reverse resolution lookups"
 },
 {
  "url": "/rif/lumino/explorer/own/api/",
  "title": "Lumino Explorer API",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Pre requisites Access to a synched RSK node. You can do this in a variety of ways: Run your own node on Testnet or Mainnet Compile and run a RSK node locally Mongo Database Server (Version 3.6.x) Java 8 (Lastest Release) Maven (Version 3.6.x) RSK valid account Build RIF Lumino Explorer API from code Get the code by cloning the repo Go to the path you downloaded or cloned Lumino’s code (let’s call this path $RIF_LUMINO_EXPLORER_API_PATH) Go to the application.properties and set the lumino.contract.tokenNetworkRegistry property, set the value with your Token Network registry. Set the lumino.explorer.api.account.file property to the JSON file of your RSK account. Example: lumino.explorer.api.account.file=UTC--2019-04-19T15-07-00.568000000Z--034000b5f2862d114e4b3474f79fc64aad0cb742.json Set the lumino.explorer.api.account.password property to the password of your account. Example: lumino.explorer.api.account.paassword=3XhLXn[(Tub6&#39;~Qe Install project dependencies with the follow command: mvn install Set Up Mongo Database Go to $RIF_LUMINO_EXPLORER_API_PATH/src/main/resources/database/ Run the following command when the mongodb server is installed on the local machine: user:~/mongo lumino-explorer-api-database-setup.js If an error is showed, you must execute the following script, specifying…"
 },
 {
  "url": "/develop/apps/tools/explorer/api/",
  "title": "API",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/marketplace/architecture/",
  "title": "RIF Marketplace Architecture",
  "category": "",
  "tags": "rif, marketplace, architecture",
  "date": "",
  "desc": "The RIF Marketplace at its core is composed of a set of smart contracts deployed on the RSK blockchain, a read-only cache for performance and scalability, and a front-end (UI) which allows users to easily connect, browse available services and features, and interact with other participants. Each specific RIF service node (RIF Services) must connect to the Marketplace Smart Contracts, listen for the required events, and ensure a proper interaction and provision of that service to the End-user. The diagram below shows an overview of the RIF Marketplace architecture, which is explained next: RIF Marketplace is built around 3 core components: UI-Frontend Dapp Cache Smart Contracts UI-Frontend Dapp End-Users interact with the RIF Marketplace through the main Marketplace Dapp (RIF Marketplace UI). This web application presents information about the service categories available, allows users to browse/search for specific providers, and allows providers and consumers to engage in service agreements. It also allows Providers to register their offered services and track their performance and current customers, manage their staking, among other functionalities. Cache The information presented in the UI comes from RIF Marketplace Cache. This component is always…"
 },
 {
  "url": "/rif/lumino/node/architecture/",
  "title": "Architecture",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "TODO: missing doc"
 },
 {
  "url": "/rif/communication/architecture/",
  "title": "Architecture",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "RIF Communication consist of 3 distinct layers (from the top to the bottom as shown in the figure below): User facing layer Developer facing layer Routing network layer Let’s discuss a each layer in greater detail. User facing layer The user facing layer contains services that are using the RIF Communication protocol and libraries. This layer will contain mostly 3rd party solutions as we are focused on building the infrastructure layers. However, we are building 3 services that we see as necessary for the success of the platform. RIF Communication Gateways allows users, for a small fee, to interact with RIF Communication network without the need of operating node while allowing gateway operators to profit. This is a service open to 3rd parties to operate and has some privacy caveats. The Mailbox service gives users to receive messages even if they are not online. It is similar to real world mailbox service and as such it also has privacy trade-offs. Mailbox services will be listed on RIF Marketplace. Node operators can use Node manager to monitor their communication instances and understand the utilization of their service. Developer facing layer …"
 },
 {
  "url": "/rif/storage/architecture/",
  "title": "storage/architecture",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "RIF Storage consist of 3 distinct layers (from the top to the bottom as shown in the figure below): User facing layer Developer facing layer Storage layer User facing layer The user facing layer contains services that are using the RIF Storage protocol and libraries. As we are focused on building the infrastructure layers, this layer will contain mostly 3rd party solutions. However, we are building 3 services that we see are necessary for success of the platform: RIF Storage Gateways allows users to interact with RIF Storage for a small fee, without the need of an operating node while allowing gateway operators to profit. This is a service open to 3rd parties to operate. The Pinning service gives any storage provider the opportunity to guarantee persistance of files and be rewarded for the service. Pinning services will be listen on RIF Marketplace. Node operators can use Node manager to monitor their storage instances and understand the utilization of their service. Developer facing layer We are providing dApp developers a unified API allowing them to seamlessly utilize any of the supported storage providers or even switch…"
 },
 {
  "url": "/tools/explorer/blockscout/",
  "title": "Blockscout",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tools/truffle/boxes/",
  "title": "Truffle Boxes",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/guide/brave/",
  "title": "Connect Brave to the RSK Network - RNS User guide",
  "category": "",
  "tags": "rns, guide, rns-user-guide",
  "date": "",
  "desc": "How to locate Brave&#39;s Wallet, connect to the RSK Mainnet and Testnet, get your RSK account address, add the RIF token"
 },
 {
  "url": "/contribute/bug-bounty-program/",
  "title": "Bug Bounty Program",
  "category": "",
  "tags": "rsk, rif, bounty, security",
  "date": "",
  "desc": "IOVLabs has created this bug bounty program to reward security researchers that dedicate time and effort to improve the IOVLabs platforms. Bug Bounty Program"
 },
 {
  "url": "/webinars/calendar.ical",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/compile-smart-contracts-go/",
  "title": "Compile Smart Contracts to Go",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/storage/providers/swarm/configure/",
  "title": "Running Configurations for Swarm",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Use the following cheatsheet to run Swarm with the desired capabilities. For a full list of the available command line options for swarm, see here. Table of Contents RNS Resolution ENS Resolution Incentivization • RNS Resolution You can resolve RNS addresses by specifying the RNS Resolver Smart Contract to use through the rns-api flag. For example: swarm --rns-api 0x99a12be4C89CbF6CFD11d1F2c029904a7B644368@https://public-node.rsk.co In this example: 0x99a12be4C89CbF6CFD11d1F2c029904a7B644368 is the address for the RNS Resolver contract. https://public-node.rsk.co is the RSK blockchain endpoint to be used when interacting with the contract. • ENS Resolution Swarm cannot resolve ENS addresses by itself; it needs to delegate this task. There are 2 ways to do this. Through Geth The easiest way to do this is to run a Geth node locally and let Swarm make calls to this instance when attempting to resolve addresses. Run Geth through the geth command (to install Geth, follow these instructions). Leave the node running long enough so that it’s in-sync with the blockchain. Tip: save resources by running Geth in light mode: &amp;lt;pre…"
 },
 {
  "url": "/tools/tokenbridge/contractaddresses/",
  "title": "Addresses and Links",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/lumino/node/contribute/",
  "title": "Creating an Issue",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "If you find an issue in Lumino and want to report it, or you want to request a feature. You can make an issue in the github repo, we suggest to create an issue with the following structure: For Feature Requests: Full description of the feature Explanation of why you think it’s useful for Lumino. For Bugs: Short description for the problem Setup description (System you’re using, Lumino version, RSKj version, etc) Explain exactly what was the bug Expected behavior Creating a Pull Request To contribute with the codebase of Lumino, you can open a Pull Request (PR) against our repository. All PRs should be: Self-contained. As short as possible and address a single issue or even a part of an issue. Consider breaking long PRs into smaller ones. It should have a test that allow to verify the fix or functionality To get you PR merged into the main repository, you should have at least one approved review from our Lumino dev team."
 },
 {
  "url": "/tutorials/tokens/create-a-collectable-token/",
  "title": "Create your own collectable token on RSK network",
  "category": "",
  "tags": "tutorial, rsk, token, openzeppelin, erc721, truffle, frontend, web3, react",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/tokens/create-a-token-02/",
  "title": "Create a token - other approach",
  "category": "",
  "tags": "tutorial, rsk, token, openzeppelin, erc20, truffle",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/tokens/create-a-token/",
  "title": "Create your first token",
  "category": "",
  "tags": "tutorial, rsk, token, openzeppelin, erc20, truffle",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tools/tokenbridge/dappguide/",
  "title": "Token Bridge Dapp Guide",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/storage/providers/swarm/guides/debugging/",
  "title": "Debugging Swarm",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "1. Open the swarm project Load the entire Swarm project into your favorite IDE. The default location should be $GOPATH/src/github.com/ethersphere/swarm. 2. Alter the main function Locate the main() function, under swarm/cmd/swarm/main.go. This function is called when starting Swarm through the swarm terminal command, therefore its arguments must be injected, like so: func main() { // injection of swarm arguments options := []string{ &quot;--bzzaccount=0x2f1cd699b0bf461dcfbf0098ad8f5587b038f0f1&quot;, &quot;--password=/home/usr/password.txt&quot;, // other CLI arguments here... } args := append(os.Args, options...) if err := app.Run(args); err != nil { fmt.Fprintln(os.Stderr, err) os.Exit(1) } } Each of the elements in the options array holds a swarm command option and its value, in the --option=value form. Replace the example with your own values, and add or remove any flag as needed. For a full…"
 },
 {
  "url": "/rif/rns/architecture/definitive-resolver/",
  "title": "Resolver",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "RSK Mainnet: 0xD87f8121D44F3717d4bAdC50b24E50044f86D64B RSK Testnet: 0x25C289ccCFFf700c6a38722F4913924fE504De0e Repo: rnsdomains/rns-resolver Features Supported resolution protocols: Contract addresses - EIP-137 Multicoin addresses - EIP-2304 Contenthash - EIP-1577 Contract ABI - EIP-205 SECP256k1 public keys - EIP-619 Text records - EIP-634 Interface discovery - EIP-1844 Architecture: Upgradeable contracts using OpenZeppelin Upgrades. Use setAuthorisation to enable others set your records. Use multicall to perform multiple operations in one call/transaction. Public methods Resolution protocols Contract and multicoin addresses: addr and setAddr Contenthash: contenthash and setContenthash Contract ABI: abi and setAbi SECP256k1 public keys: pubkey and setPubkey Text records: text and setText Interface discovery: interfaceImplementer and setInterfaceImplementer Administrative Authorisations: authorisations, setAuthorisation and isAuthorised Multiple calls: multicall Authorisations Any account can set an authorisation for any name, but the authorisation that is checked will be that of the current owner of a name. Thus, transferring a name effectively clears any existing authorisations, and new authorisations can be set in advance of…"
 },
 {
  "url": "/tutorials/deploy-smart-contracts/",
  "title": "Deploy Smart Contracts",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/marketplace/dev-setup/",
  "title": "RIF Marketplace Development Environment",
  "category": "",
  "tags": "rif, marketplace, development, environment",
  "date": "",
  "desc": "This page provides a guide for developers to set up the environment for the RIF Marketplace project. Contents: Dependencies Prerequisities Part of tutorial Setup [Developers Environment] Starting docker Deploying smart contracts Browser wallet RIF Marketplace Cache RIF Marketplace UI RNS Manager Using the RIF Marketplace Dependencies Prerequisities node v10 (or nvm with node v10 installed) Docker Docker compose Part of tutorial These will be installed during the tutorial RIF Marketplace Developer Environment project RIF Marketplace Cache project RIF Marketplace UI project RNS Manager Project Setup: 1. Developers Environment Download and setup the RIF Marketplace Developer Environment git clone git@github.com:rsksmart/rif-marketplace-dev.git cd rif-marketplace-dev 1.1. Starting docker Now you can start docker with docker-compose up The Ganache blockchain will now run and it is available to deploy the corresponding Smart Contracts. 1.2. Deploying smart contracts First, install the dependencies (make sure to use node v10, you can switch using nvm use 10). &amp;lt;div…"
 },
 {
  "url": "/rif/rns/integrate/domain-keys-management/",
  "title": "Domain keys management guidelines",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Work in progress :hammer:"
 },
 {
  "url": "/rif/rns/integrate/domain-registration/",
  "title": "Domain keys management guidelines",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Work in progress :hammer:"
 },
 {
  "url": "/tools/tokenbridge/faq/",
  "title": "Token Bridge FAQ",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tools/faucet/",
  "title": "RSK Tesnet Faucet",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/architecture/rsk-registrar/registrars/fifs/",
  "title": "First-in first-served .rsk registrar",
  "category": "",
  "tags": "rns, fifs, registrar",
  "date": "",
  "desc": "Register an RNS address using the FIFS registrar, without address resolution"
 },
 {
  "url": "/rif/rns/architecture/rsk-registrar/registrars/fifsaddr/",
  "title": "First-in first-served + address setup .rsk registrar",
  "category": "",
  "tags": "rns, fifs, registrar",
  "date": "",
  "desc": "Register an RNS address using the FIFS registrar, with address resolution"
 },
 {
  "url": "/tutorials/frontend/first-frontend-web3-injected/",
  "title": "How to create your first frontend for smart contracts",
  "category": "",
  "tags": "tutorial, rsk, frontend, web3",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/dweb/first-swarm-website/",
  "title": "How to deploy your first decentralised website on Swarm",
  "category": "",
  "tags": "tutorial, rif, swarm, website, dweb",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/frontend/frontend-web3-local/",
  "title": "Create a frontend for smart contracts using web3 connected to a local node",
  "category": "",
  "tags": "tutorial, rsk, frontend, web3",
  "date": "",
  "desc": ""
 },
 {
  "url": "/develop/apps/tools/truffle/ganache/",
  "title": "Ganache",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tools/truffle/ganache/",
  "title": "Ganache",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/develop/apps/tools/gas-station/",
  "title": "Gas Station",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Gas Station The RSK Gas Station portal provides metrics for the RSK gas market. At this site, you can find the current and historical information about the RSK gas price as well as the comparssion to other main stream public chains. RSK Gas Station Website Visit RSK Gas Station through this link http://rskgasstation.info RSK Gas Station Interface The top section provides the current Tx Price and Token Value for RSK, ETH, and BTC. The middle section provides the movement of RSK and ETH Tx Price over the last 14 days in a chart as well as a table for easy reading. The bottom section provides a plot of the Tx Price in minutes for the last 24 hours."
 },
 {
  "url": "/rif/rns/operations/get-reverse/",
  "title": "Find the name of an address",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "This process describes how to find a name for a given address. This depends on the owner of the account having set its reverse resolution. Go to resolution page In the top text input, type an address in lower case, without 0x at the beginning, followed by .addr.reverse. Example Expose my account’s name"
 },
 {
  "url": "/tutorials/ethereum-devs/geth-attach-deploy-smart-contract/",
  "title": "Deploy a smart contract at RSK local node using Geth and Remix",
  "category": "",
  "tags": "tutorial, rsk, geth, remix, ethereum, smart contract",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/ethereum-devs/geth-attach-local-node/",
  "title": "Using geth to attach to a RSK local node",
  "category": "",
  "tags": "tutorial, rsk, geth, ethereum",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/guide/getting-started/",
  "title": "Getting started - RNS User guide",
  "category": "",
  "tags": "rns, guide, rns-user-guide",
  "date": "",
  "desc": "How to register a domain, log in to a domain, log out of a domain, change the language"
 },
 {
  "url": "/rif/marketplace/guide/getting-started/",
  "title": "Getting Started - RIF Marketplace User Guide",
  "category": "",
  "tags": "rif, marketplace, guide",
  "date": "",
  "desc": "RIF Marketplace User Guide"
 },
 {
  "url": "/tutorials/hello-world/",
  "title": "Hello World!",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/libs/iOS/",
  "title": "iOS Library",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Implementation for resolvers for the RIF Name Service, available for iOS. Installation RNS is available through CocoaPods. To install it, simpy add the following line to your Podfile: pod &quot;Rns&quot; How to use You will need access to a running rsk node that can made calls to the JSON-RPC. For this we have our public nodes available for you, that are already configured in our Info.plist file. You can just create your resolver with the default constructor if you are going to use mainnet. let resolver = new RnsResolver(); Or you can use another constructor if you want to use a personal node. let resolver = new RnsResolver(nodeDir: &quot;http://your.node.org&quot;, publicResolverAddress:&quot;RSK_ADDRES_TO_YOUR_RESOLVER&quot;); Then you can start using your resolver. Sample app Download the code of the RNS iOS sample app."
 },
 {
  "url": "/roadmap/improvement-proposals/",
  "title": "Improvement Proposals",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/storage/providers/swarm/incentives/",
  "title": "Swarm Incentives",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "File sharing systems heavily rely on users distributing files to others willingly. But strictly speaking, a user could choose to download a file and consume resources without uploading in return. Incentivization is of major importance for such systems. Why? Think for a second about whether you would like to have your laptop connected, and storing and serving file chunks from your hard-drive 24/7. No? Well, probably you are not the only one. Ask yourself another question: what would make you willing to serve chunks and contribute to a healthy network? Swarm Incentives Swarm defines the Swarm Accounting Protocol (SWAP), which is a tit-for-tat system where nodes account how much data they request and serve. Basically, this means that if a node requests a million chunks from another, it will serve one million chunks in return. However, there is a problem with this in a network of file storage. We expect a variability in network usage (a node might stream a video for 2 hours, but then be idle for the upcoming 4 hours) as well as differences in capabilities of nodes (a phone won’t be able to serve many chunks, whereas a server can). SWAP allows nodes to keep…"
 },
 {
  "url": "/webinars/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/the-stack/",
  "title": "The Stack",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "DeFi Wallet Exchange Asset Tokenization Stablecoins Payments Margin Trading Lending and borrowing Derivatives Insurance Escrow Prediction Markets Marketplaces Scoring Liquidity protocols Libraries RIF Marketplace RIF Directory RIF Payments RIF Storage RIF Comms RIF Gateways Your sharing economy rsk smart contracts Bitcoin: Store of Value"
 },
 {
  "url": "/newsletter/",
  "title": "Newsletter",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/guide/",
  "title": "RNS User guide",
  "category": "",
  "tags": "rns, guide, rns-user-guide",
  "date": "",
  "desc": "A user guide for the RIF Name Service"
 },
 {
  "url": "/rif/rns/operations/",
  "title": "Operations",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Registration: Register an .rsk domain Resolution: Resolve a domain’s address Change resolver Set address resolution Set Bitcoin address resolution Ownership admin: Renew a domain Transfer a domain Subdomains: Register a subdomain Change subdomain’s owner Reverse lookup: Expose the name of your address Find the name of an address Register with auction model?: Migrate a domain from auction registration"
 },
 {
  "url": "/rif/rns/tools/",
  "title": "Tools",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Web3 MyCrypto RNS Manager Subdomain tool"
 },
 {
  "url": "/rif/rns/specs/",
  "title": "RNS Specs",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "RNS specifications, and name mapping convention"
 },
 {
  "url": "/rif/rns/architecture/rsk-registrar/registrars/",
  "title": "RSK Registrars",
  "category": "",
  "tags": "rns, registrar",
  "date": "",
  "desc": "RNS registrars"
 },
 {
  "url": "/rif/rns/architecture/rsk-registrar/renewers/",
  "title": "RSK Renewers",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Simple renewer"
 },
 {
  "url": "/rif/rns/architecture/rsk-registrar/",
  "title": ".rsk Registrar",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "The registrar is separated into several components for simplicity, modularity, and privilege minimization. RSK Owner is the owner of rsk top level domain, so it is the only contract that can invoke setSubdomainOwner in RNS Registry. It grants access to other contracts for registering new domains and/or renewing domain’s expiration time. Currently we’ve enabled a first-in first-served registrar contract and a simple renewer contract that enable minimal actions to provide basic functionality for domain creation and administration."
 },
 {
  "url": "/rif/rns/architecture/",
  "title": "Architecture",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "The RIF Name Service architecture is based on 3 main components: The RNS Registry. A tree-structured registry that provides an owner, a resolver, and a TTL for each existing domain. The resolver of a domain is a contract that provides information from a name in response to client requests. The owner of a domain can be an account or a contract, and is the only one who can create subdomains. Contracts that own domains are called Registrars. RNS provides a public registrar for registering .rsk domains, currently the only active top level domain. RNS also provides the necessary architecture to perform reverse lookups, this means finding a related domain for a given address. Read the specs to know more about the motivation for this architecture design."
 },
 {
  "url": "/rif/rns/integrate/",
  "title": "RNS Integration guidelines",
  "category": "",
  "tags": "rns, javascript, dapp, wallet, integrate",
  "date": "",
  "desc": "Learn how to integrate RNS with your wallet or dApp."
 },
 {
  "url": "/rif/rns/libs/rns-artifacts/resolver/",
  "title": "RNS Solidity artifacts - resolvers",
  "category": "",
  "tags": "rns, artifacts, resolvers",
  "date": "",
  "desc": "The Resolver contract handles the resolution between the name domain and the resource. Each Registry entry references a Resolver. Further reading Resources String Resolver: stores string resolution for a given domain."
 },
 {
  "url": "/rif/rns/libs/rns-artifacts/",
  "title": "RNS Solidity artifacts",
  "category": "",
  "tags": "rns, artifacts",
  "date": "",
  "desc": "RNS artifacts is a library for smart contract development. Source: github.com/rnsdomains/rns-artifacts It provides implementations of RNS Registry, Registrars, and Resolvers which you can deploy as-is or extend to suit your needs, as well as Solidity components to build custom contracts and more complex decentralized systems. Resolver: contract responsible for performing resource lookups for a name - for instance, returning a contract address, a content hash, or IP address(es) as appropriate. String Resolver"
 },
 {
  "url": "/rif/rns/libs/javascript/",
  "title": "RNS JS Library",
  "category": "",
  "tags": "rns, javascript",
  "date": "",
  "desc": "Learn more about RNS JS Library."
 },
 {
  "url": "/rif/rns/libs/",
  "title": "RNS Libraries",
  "category": "",
  "tags": "rns, libs",
  "date": "",
  "desc": "RIF Name Service is part of the RIF Open Platform ecosystem. The developer community is working to help other developers enabling libraries and SDKs. Platform Component Javascript Resolver Android Resolver | Sample App iOS Resolver | Sample App Python Resolver Solidity RNS Full Smart contract suite | rns-artifacts"
 },
 {
  "url": "/rif/rns/",
  "title": "RIF Name Service",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "RNS provides an architecture which enables the identification of blockchain addresses by human-readable names. .rsk Register! Try the service Register a domain in the Testnet, for free. Integrate with RNS Easy guides on how to integrate RNS in your solution. Develop on top of RNS Deploy RNS suite in your local development environment Use the libraries Use simple libraries to interact with RNS service. The stack RNS dApp Libraries Smart contracts Specifications Motivation By adding a name resolution service, also known as “alias”, the probability of errors…"
 },
 {
  "url": "/rif/marketplace/guide/",
  "title": "RIF Marketplace User Guide",
  "category": "",
  "tags": "rif, marketplace, guide",
  "date": "",
  "desc": "RIF Marketplace User Guide"
 },
 {
  "url": "/rif/marketplace/services/rnsdomains/",
  "title": "RIF Marketplace Services RNS Domains",
  "category": "",
  "tags": "rif, marketplace, rns",
  "date": "",
  "desc": "Technical Specifications"
 },
 {
  "url": "/rif/marketplace/services/",
  "title": "RIF Marketplace Services RNS",
  "category": "",
  "tags": "rif, marketplace, services",
  "date": "",
  "desc": "RNS Buy Sell Domains"
 },
 {
  "url": "/rif/marketplace/",
  "title": "About RIF Marketplace",
  "category": "",
  "tags": "rif, marketplace",
  "date": "",
  "desc": "The RIF Marketplace serves as the main component through which all the other RIF services connect with their end-users and customers. It is designed as a one-stop-shop for a wide variety of decentralized services, allowing providers and consumers to meet in a secure and efficient way. The main goal of the RIF Marketplace is to enable the fast and efficient creation of decentralized sharing economies (DSE) on top of RSK and RIF, providing the required tools to bring all parties together. Providers can list their offerings and connect with potential users for a vast range of decentralized services such as Storage, Payments, Communications, and Data Services, presenting at the same time a common and unified interface and user experience. You can access the Marketplace on the RSK Tesnet: marketplace.testnet.rifos.org"
 },
 {
  "url": "/rif/lumino/explorer/own/",
  "title": "Run your own explorer",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "If you want to run your own explorer, you have to setup the API and the web. API Web"
 },
 {
  "url": "/rif/lumino/explorer/",
  "title": "Lumino Explorer How To Use",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Repository: https://github.com/rsksmart/lumino-explorer Mainnet public explorer: https://explorer.lumino.rifos.org/ RIF Lumino Explorer is a website which allows us to view the status of the Lumino Network. Each node can decide to be present or not in this explorer. Dashboard On the dashboard we have several sections: Node graph: At the center of the screen we can see all the nodes which opted to be included in the explorer and how they connect between each other Tokens dropdown: Above the graph, there is a dropdown which allows us to select which token we want to display information for. Search box: allow to search by: Node address Channel id Token Ot the left, we have a summary of the network At the top right we have 2 buttons to go to: View all nodes View all channels Summary Widget At the left of the dashboard we will see a summary widget with some general information about the network and the token selected in the dropdown. In the Dashboard (Screenshots above) we got some statistics from the Mainnet. How many nodes are connected to the…"
 },
 {
  "url": "/rif/lumino/light-client/use/",
  "title": "Light Client SDK Tutorial",
  "category": "",
  "tags": "lumino, client, rif",
  "date": "",
  "desc": "How to use the RIF Lumino Light Client SDK"
 },
 {
  "url": "/rif/lumino/light-client/specs/",
  "title": "Light Client",
  "category": "",
  "tags": "lumino, client, rif",
  "date": "",
  "desc": "Lumino Light Client design and implementation specifications"
 },
 {
  "url": "/rif/lumino/node/install/",
  "title": "Install",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Install your own Lumino Node Install on Ubuntu Install on MacOS"
 },
 {
  "url": "/rif/lumino/node/",
  "title": "Lumino Node",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Here you’ll find more information about Lumino Node: Architecture Install How to use Protocol Contribute"
 },
 {
  "url": "/rif/lumino/libraries/",
  "title": "Libraries",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "The developer community is working to help other developers enabling libraries and SDKs. Platform Component Javascript Lumino JS SDK"
 },
 {
  "url": "/rif/lumino/",
  "title": "RIF Lumino Network",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "The RIF Lumino Network is the first off-chain state channel network launched on RSK. It is also a cornerstone of a broader vision called RIF Payments which will allow users to seamlessly interact with multiple cross-blockchain off-chain networks such as Lumino, Lightning and Raiden. RIF Lumino allows to make off-chain payments on any token deployed on RSK in a fast, reliable, with low fees and secured by the Bitcoin network. RIF Lumino will be the first payment network supported by RIF Payments in his path to a global financial inclusion. If you want to read more about RIF Lumino and how to be part of the network please follow the link https://explorer.lumino.rifos.org/ RIF Payments is a set of protocols whose primary goal is to enable fast and cheap peer-to-peer payments that could scale to achieve true world-wide financial inclusion. RIF Payments is composed of three main protocols: RIF Payments Full: it is a protocol which creates an abstraction layer to access different payment networks allowing cross-token and cross-network payments. RIF Payments Light: it is a protocol to allow light clients to access RIF Payments Full without jeopardizing security and decentralization. RIF Payments Exchange: this protocol will be used…"
 },
 {
  "url": "/rif/communication/",
  "title": "About RIF Communication",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "RIF Communications is an infrastructure protocol built on top of libp2p, which allows parties in a peer-to-peer network to discover each other and establish secure communication channels, with assured anonymity, confidentiality, integrity, and authenticity. Confidentiality: no third-party can read the sent messages. Integrity: prevention of a third-party of modifying the sent messages. Authenticity: prevention of impersonation of any of the endpoints. Anonymity: If enabled, nobody in the network can identify the sender or the recipient for any particular message. By using their public keys as a discovery mechanism, users can publish pseudonyms on the RIF Directory and be discoverable without the need to remember long public keys. The RIF Secure Communications Infrastructure protocol aims to fulfill the need for establishing secure links between end users, RIFOS parties or services. In addition, RIF Communication also aspires to expose a low level library suitable to be used as communication layer in decentralised applications like RSK node, Lumino network node and similar."
 },
 {
  "url": "/rif/storage/providers/swarm/guides/",
  "title": "storage/providers/swarm/guides/index",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "WIP"
 },
 {
  "url": "/rif/storage/providers/swarm/",
  "title": "About Swarm",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Swarm is a censorship resistant, permissionless, decentralised storage and communication infrastructure. This base-layer infrastructure provides these services by contributing resources to each other. These contributions are accurately accounted for on a peer to peer basis, allowing nodes to trade resource for resource, but offering monetary compensation to nodes consuming less than they serve. From the end user’s perspective, Swarm is not that different from the world wide web. In the background, the difference is that content is hosted on a peer-to-peer storage network instead of individual servers. This peer-to-peer network is self-sustaining due to a built-in incentive system which uses peer-to-peer accounting and allows trading resources for payment. Swarm is designed to deeply integrate with the devp2p multiprotocol network layer of Ethereum as well as with the Ethereum blockchain for domain name resolution, service payments and content availability insurance. Resources Links Official website Documentation Github repository Papers Swap, Swear and Swindle: Incentive System for Swarm Viktor Trón, Aron Fischer, Dániel A. Nagy, Zsolt Felföldi &amp;amp; Nick Johnson (2016). Generalised Swap Swear and Swindle Games Viktor Trón &amp;amp; Aron Fischer (2019). Presentations Swap, Swear and Swindle…"
 },
 {
  "url": "/rif/storage/providers/ipfs/",
  "title": "IPFS",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "IPFS stands for Interplanetary File System. At its core it is a versioned file system which can store files and track versions over time, very much like Git. It also defines how files move across a network, making it a distributed file system, much like BitTorrent. In combining these two properties, IPFS enables a new permanent web and augments the way we use existing internet protocols like HTTP."
 },
 {
  "url": "/rif/storage/providers/",
  "title": "storage/providers/index",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "WIP"
 },
 {
  "url": "/rif/storage/",
  "title": "About RIF Storage",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "RIF Storage is an open, censorship resistant, permissionless and decentralized storage protocol. It provides a unified interface to a 3rd party decentralized storage providers like IPFS or Swarm making it easy . We are adding incentives to these systems to ensure resistance to trivial attacks, availability and to allow participants to be rewarded for their participation in the network. As an end-user RIF Storage allows you to take back ownership of your data. Even if service you are using stops existing you can retrieve all your content. As a developer/service creator RIF Storage allows you to not worry about storage for your application and it also comes with content delivery service out of the box so your application scales without you having to invest in the infrastructure. Thanks to the build in incentives, anyone is able to become storage provider and offer their unused storage to others and get paid for it."
 },
 {
  "url": "/rif/",
  "title": "RSK Infrastructure Framework",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "RIF Services RSK Infrastructure Framework Open Standard (RIF OS) is a suite of open and decentralized infrastructure protocols that enable faster, easier and scalable development of distributed applications (dApps) within a unified environment. RIF OS is an all in one, easy to use, blockchain infrastructure service framework that provides developers and organizations access to a variety of services across multiple crypto-economies. RIF OS Protocols enable broad interoperability and faster time-to-deployment, and aim to bridge the gap between blockchain technologies and their mass-market adoption. RIF OS Protocols complete the RSK Smart Contract Network vision of bringing the Internet of Value to life. RIF Name Service RNS is a decentralized service that allows users to have a readable domain or alias. It can be used to identify other personal resources, such as payment or communication addresses. Learn more about RIF Name Service RIF Lumino Network RIF Lumino Network is a third-layer solution to the Bitcoin blockchain, that enables state channels for every token built on RSK increasing transaction throughput and reduces costs by orders of magnitude. Learn more about RIF Lumino Network RIF Marketplace RIF Marketplace provides a…"
 },
 {
  "url": "/develop/apps/tools/explorer/",
  "title": "Explorer",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Overview Of The Explorer You can browse the overview of RSK on this page with https://explorer.rsk.co/ like below. Switch between Tabs If you want to view some specific information, you can jump through the tab bar below. Search for some information you want You can search for the information you want by entering the address,block number or tx hash in the search box. Last Block Information The next section is a panel about the last block. You can see the block number, address, the total number of transactions, and the duration in turn. Click on the number link and you can jump to the detailed page of this block. Especially,you can copy the address code by clicking the icon over the string. If you don’t need automatic update status, you can turn off the following switch. Last Block Transactions The bar…"
 },
 {
  "url": "/develop/apps/tools/truffle/",
  "title": "Truffle",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/develop/apps/tools/",
  "title": "Tools",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tools/explorer/",
  "title": "Explorer",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tools/truffle/",
  "title": "Truffle Overview",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tools/tokenbridge/",
  "title": "RSK  ETH Token Bridge",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tools/",
  "title": "Tools",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/contribute/",
  "title": "Contribute",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "The RSK stack is open-source, if you are interested in colaborate, follow these links: RSKj (node) RNS Lumino node RSK Github Check out our bug bounty program."
 },
 {
  "url": "/ethereum-dapp-to-rsk/",
  "title": "Bring your Ethereum token to RSK",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/wallet/use/",
  "title": "Wallets",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/wallet/rwallet/",
  "title": "rWallet",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/wallet/",
  "title": "Wallets",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/contact/",
  "title": "Engage",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/ethereum-devs/",
  "title": "Tutorials for Ethereum Developers",
  "category": "",
  "tags": "tutorial, rsk, ethereum",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/tokens/",
  "title": "Tutorials about tokens",
  "category": "",
  "tags": "tutorial, rsk, token",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/frontend/",
  "title": "Tutorials for build frontend",
  "category": "",
  "tags": "tutorial, rsk, frontend",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/",
  "title": "Tutorials",
  "category": "",
  "tags": "tutorial, rsk",
  "date": "",
  "desc": ""
 },
 {
  "url": "/libraries/rsk-precompiled-abis/",
  "title": "RSK Pre-compiled ABIs",
  "category": "",
  "tags": "libraries, abi, pre-compiled",
  "date": "",
  "desc": ""
 },
 {
  "url": "/libraries/rsk3js/docs/",
  "title": "rsk3.js",
  "category": "",
  "tags": "libraries, rsk, rsk3js, javascript, web3js",
  "date": "",
  "desc": ""
 },
 {
  "url": "/libraries/rsk3js/",
  "title": "rsk3.js",
  "category": "",
  "tags": "libraries, rsk, rsk3js, javascript, web3js",
  "date": "",
  "desc": ""
 },
 {
  "url": "/libraries/",
  "title": "Libs",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/storage/providers/swarm/install/",
  "title": "Installing Swarm",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "To install Swarm, you can download the latest binaries or—alternatively—compile them directly from the source code. Download the binaries (recommended) Pre-compiled binaries for Linux, macOS and Windows are available to download from the Swarm official homepage. Compile from source code Prerequisites 1. Git To install git, follow the instructions here. 2. Golang To install go, follow the instructions here. 2.1 Set up Go environmnet Make sure the GOPATH environment variable is set: echo &#39;export GOPATH=$HOME/go&#39; &amp;gt;&amp;gt; ~/.bashrc echo &#39;export PATH=$GOPATH/bin:$PATH&#39; &amp;gt;&amp;gt; ~/.bashrc source ~/.bashrc Create the $HOME/go directory if it doesn’t exist: mkdir $HOME/go Verify this step was successful through echo $GOPATH. Create the Swarm binaries If needed, create the directory for the project: mkdir -p $GOPATH/src/github.com/ethersphere Clone the repo: cd $GOPATH/src/github.com/ethersphere/ &amp;amp;&amp;amp; git clone https://github.com/ethersphere/swarm Compile the Swarm binaries: cd $GOPATH/src/github.com/ethersphere/swarm &amp;amp;&amp;amp; make swarm Check the Swarm version: &amp;lt;div…"
 },
 {
  "url": "/rif/rns/integrate/integrate-addr-resolution/",
  "title": "Use domains instead of long hexa addresses",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "This is a demonstration of how to get the address of a domain. We are going to do it in a React app. Requirements Node npm yarn create-react-app Recipe Create a new react app create-react-app rns-addr-sample-app cd rns-addr-sample-app Install @rsksmart/rns and web3. yarn add web3 @rsksmart/rns Update your App.js file import React, { Component } from &#39;react&#39;; import Web3 from &#39;web3&#39;; import RNS from &#39;@rsksmart/rns&#39;; export default class extends Component { constructor(props) { super(props); this.state = { domain: &#39;&#39;, getting: false, addr: null, error: null, }; this.handleDomainChange = this.handleDomainChange.bind(this); this.&amp;lt;span…"
 },
 {
  "url": "/rif/rns/integrate/integrate-dapp/",
  "title": "Integrate your dApp with RNS",
  "category": "",
  "tags": "rns, javascript, dapp, integrate",
  "date": "",
  "desc": "Learn how to integrate RNS with your dApp."
 },
 {
  "url": "/rif/rns/integrate/integrate-wallet/",
  "title": "Integrate your wallet with RNS",
  "category": "",
  "tags": "rns, wallet, javascript, integrate",
  "date": "",
  "desc": "The first thing you need to do is to register the name of your wallet now! Search for it here: .rsk Register! Content Use domains instead of addresses within your wallet Use RSK domains User other blockchain domains Set your users address resolution to domains Set RSK address Set other blockchain address Register subdomains for newcomers Check for available subdomains Different ways to perform registrations Create a backend that executes registrations Create a smart contract that gifts subdomains Use the batch registration tool Create more subdomains under a user subdomain This tutorial has been created to be used with the RNS JS library. The library needs Web3 to be instantiated, so if you already use Web3, welcome to the journey! If not, don&#39;t worry, you are still able to check out our smart contracts architecture and interact directly with…"
 },
 {
  "url": "/develop/apps/integrate/",
  "title": "How to Integrate",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Step 1: Install a node RSK nodes can be installed on all major platforms, including Linux, Windows, and Mac. Install node Step 2: Create a Wallet The RSK network is account-based and incorporates an optional blockchain identifier, also known as chain-id. About addresses Create a Wallet Step 3: Get R-BTC The Smart Bitcoin (R-BTC) is the token used to pay for the execution of transactions in RSK. Test R-BTC Buy R-BTC Step 4: Connect your app Smart contracts for RSK are written using Solidity and are fully compatible with Ethereum Smart Contracts, so you can migrate your existing Ethereum Smart Contract to RSK Smart without making any changes. Port Ethereum dApps More Tutorials"
 },
 {
  "url": "/tutorials/interact-with-smart-contracts/",
  "title": "Interact with Smart Contracts",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/interface-registry/",
  "title": "Universal Smart Contract Interface Registry",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/guide/intro/",
  "title": "Intro - RNS User guide",
  "category": "",
  "tags": "rns, guide, rns-user-guide",
  "date": "",
  "desc": "What is RNS, and how to use the testnet"
 },
 {
  "url": "/rif/marketplace/guide/intro/",
  "title": "Introduction - RIF Marketplace User Guide",
  "category": "",
  "tags": "rif, marketplace, guide",
  "date": "",
  "desc": "RIF Marketplace User Guide"
 },
 {
  "url": "/rif/storage/libraries/javascript/",
  "title": "RIF Storage JS",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Install npm &amp;gt; npm install @rsksmart/rif-storage Use in Node.js var RifStorage = require(&#39;@rsksmart/rif-storage&#39;) Use in a browser with browserify, webpack or any other bundler var RifStorage = require(&#39;@rsksmart/rif-storage&#39;) Use in a browser Using a script tag Loading this module through a script tag will make the RifStorage obj available in the global namespace. &amp;lt;script src=&quot;https://unpkg.com/@rsksmart/rif-storage/dist/index.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!-- OR --&amp;gt; &amp;lt;script src=&quot;https://unpkg.com/@rsksmart/rif-storage/dist/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt; Usage This is a client library, therefore you need to provide access to the provider’s running node for specifics see Providers. import RifStorage, { Provider } from &#39;@rsksmart/rif-storage&#39; // Connects to locally running node const storage = RifStorage(Provider.IPFS, { host: &#39;localhost&#39;, port: &#39;5001&#39;, protocol:…"
 },
 {
  "url": "/wallet/use/jaxx/",
  "title": "Jaxx",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/develop/json-rpc-api/",
  "title": "JSON-RPC API",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "These methods are meant to be used for mining. Mining pools should interact with this API in order to do merged mining. JSON-RPC Methods mnr_getWork mnr_submitBitcoinBlock mnr_submitBitcoinBlockTransactions mnr_submitBitcoinBlockPartialMerkle JSON-RPC API Reference mnr_getWork Returns the hash of the current block for merged mining, the boundary condition to be met (“target”), parent block hash and notify flag. Parameters none Returns blockHashForMergedMining: DATA, 32 Bytes - Hash of the RSK block that should be used for merged mining. This hash must be included after the RSKBLOCK: tag. It is a 256-bit unsigned integer represented as a hexadecimal string. target: DATA, 32 Bytes - Target difficulty that solution for current work must met to be valid. Merged mined block is solved if it’s hash is below or equal this target. Target is a 256-bit unsigned integer represented as a hexadecimal string. parentBlockHash: DATA, 32 Bytes - Parent block hash, 256-bit unsigned integer as an hexadecimal string. feesPaidToMiner: QUANTITY - Fees paid to the miner in the RSK block in 1/10^18 bitcoins. notify: Boolean - This is a boolean flag that is…"
 },
 {
  "url": "/wallet/use/json-rpc/",
  "title": "JSON-RPC",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/wallet/use/ledger/",
  "title": "Ledger App",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/storage/providers/swarm/guides/local-network-incentives/",
  "title": "Running a local Swarm network on RSK",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "This guide sets up 2 Swarm nodes in a local private network. Each of the nodes is loaded into a specific directory; i.e. the folders ./s1 and ./s2. The Swarm Accounting Protocol (SWAP) is required in order to form an incentivized network in Swarm. This requires chequebook Smart Contracts which keep track of the accounting done between Swarm nodes, and therefore there is need for a blockchain. If you need these nodes to run without incentivization, please refer to the much simpler Standard version of this guide. Table of Contents Requirements Run the network Interact with the network Restart the network Add more nodes to the network Known issues Requirements 1. RSKj RSKj will be the node used to start the local RSK blockchain. Download it from: Google Drive Swarm (make sure to rename the downloaded file to rskj-core-unformatted-log-all.jar) 2. websocat (optional) websocat is a command-line web socket client, used to query the nodes running in the private network. If you plan to query the nodes, follow the instructions here to install…"
 },
 {
  "url": "/rif/storage/providers/swarm/guides/local-network/",
  "title": "Running a local Swarm network",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "This guide sets up 2 Swarm nodes in a local private network. Each of the nodes is loaded into a specific directory; i.e. the folders ./s1 and ./s2. Swarm can be run without a blockchain, since each node—with the help of the bootnodes—will form a network with its peers through Kademlia. It is through the Swarm Accounting Protocol (SWAP) that Smart Contracts come into play in Swarm, in order to form an incentivized network. If you need these nodes to run with incentivization, please refer to the incentivized version of this guide. Table of Contents Requirements Run the network Interact with the network Restart the network Add more nodes to the network Requirements websocat (optional) websocat is a command-line web socket client, used to query the nodes running in the private network. If you plan to query the nodes, follow the instructions here to install it. Run the network 1. Choose a directory Start a terminal and run cd to move to a directory where the files for the nodes will be created. 2. Start each…"
 },
 {
  "url": "/rif/lumino/libraries/lumino-js/",
  "title": "Lumino JS SDK",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "This SDK aims to help the development of integrations with Lumino that use JavaScript, providing an easy interface to communicate with Lumino’s REST API and request the information required. For that purpose, many ES2015 features were used, and Promises are used as notation to help dealing with asynchronous code. Requirements In order to use this SDK, you’ll need the following tools: Node.js v6.3.0 or above Node installation will include NPM, which is responsible for the dependencies management. Installation Browser Checkout the repository git clone git@github.com:Lumino/lumino-js-sdk.git. Go to the lumino-js-sdk directory. Run npm install. Run gulp build. Use the bundle.js file generated in dist folder to use the SDK in the browser. Include it in your page like this: &amp;lt;script src=&quot;path/to/lumino-js-sdk.js&quot;&amp;gt;&amp;lt;/script&amp;gt; . Define the constructor like this: const Lumino = Lumino.default; Usage As said before, this SDK relies heavily on Promises, making it easier to handle the asynchronous requests made to the API. Besides that, it provides a Lumino object containing several methods corresponding to the calls to be performed. This is a generic example of how to use the SDK,…"
 },
 {
  "url": "/rif/lumino/node/install/macos/",
  "title": "Get your own RIF Lumino node up and running on MacOS",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Prerequisites Access to a synched RSK node. You can do this in a variety of ways: Public nodes Run your own node on Testnet or Mainnet Compile and run a RSK node locally An RSK account with an R-BTC balance NOT lower than 0.001 R-BTC XCode Install required libraries/software Install command line tools xcode-select --install Install Homebrew From a Terminal window run: /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; Install OpenSSL brew install openssl export LC_ALL=&quot;en_US.UTF-8&quot;\nexport LC_CTYPE=&quot;en_US.UTF-8&quot; export LIBRARY_PATH=$LIBRARY_PATH:/usr/local/opt/openssl/lib/ Install Python 3.7 brew install python3 Install PIP sudo easy_install pip Install virtualenv pip3 install virtualenv Install libpq brew install libpq Install postgresql brew install postgresql Install psycopg2 env LDFLAGS=&quot;-I/usr/local/opt/openssl/include…"
 },
 {
  "url": "/rif/rns/mainnet/",
  "title": "RNS Mainnet",
  "category": "",
  "tags": "rif, rns, mainnet",
  "date": "",
  "desc": "RNS 0xcb868aeabd31e2b66f74e9a55cf064abb31a4ad5 Resolver 0xD87f8121D44F3717d4bAdC50b24E50044f86D64B RSK Registrar RSKOwner: 0x45d3e4fb311982a06ba52359d44cb4f5980e0ef1 FIFSRegistrar: 0x779195c53cc7c1a33bd2eea5f63f2c1da8798d61 FIFSAddrRegistrar: 0xd9c79ced86ecf49f5e4a973594634c83197c35ab Renewer: 0x7a9872a7615c475b62a62b8f6e491077fb05f663 NamePrice: 0xd09adf13e482928e47e96dd6f02aad1daf7a5a47 BytesUtils: 0xe9e32c20cbce0ad4f16377bd9a84554828e86a06 Reverse ReverseRegistrar:0xd25c3f94a743b93ecffecbe691beea51c3c2d9d1 NameResolver: 0x4b1a11bf6723e60b9d2e02aa3ece34e24bde77d9 RSK Registrar legacy TokenRegistrar (auction): 0x5269f5bc51cdd8aa62755c97229b7eeddd8e69a6 Legacy resolvers Public Resolver: 0x4efd25e3d348f8f25a14fb7655fba6f72edfe93a MultiChain Resolver: 0x99a12be4C89CbF6CFD11d1F2c029904a7B644368 RNS Manager manager.rns.rifos.org"
 },
 {
  "url": "/wallet/use/metamask/",
  "title": "MetaMask",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/operations/migrate-from-auction/",
  "title": "Migrate from auction model",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Any name that has been registered using the Auction Model contract should be migrated to the new registration model. Login to the RNS Manager. You will see the following alert in the admin tab if your name has not been migrated yet. Click on “migrate”, sign the transaction, and you’re done! To renew you domain’s rent time, migrate your domain! From now on, every new domain registered under .rsk top level domain will be managed by the RSKOwner contract. This contract is in charge of domain expirations. Once you have migrated your name, follow this guide to renew your domain’s expiration. If a name is not migrated before expiration, you will lose the domain ownership. In that case, you will be prompted to [register](/rif/rns/operations/Register-a-name) your domain again."
 },
 {
  "url": "/rif/rns/integrate/multichain-address-resolution/",
  "title": "Multi-chain address resolution guidelines",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Resolving a chain address (for example, a Bitcoin address) associated to a domain consist of 4 steps: Obtain the identifier of the domain. Use namehash algorithm Get the domain’s resolver contract. Use resolver(bytes32) Detect if contract supports chainAddr(bytes32,bytes4) interface via ERC-165 interface detection. Use supportsInterface(bytes4) with interface ID: 0x8be4b5f6 ERC-165 spec Query for address resolution. Use chainAddr(bytes32,bytes4) with the domain identifier and the chain hexa identifier chainAddr(bytes32,bytes4) spec function getAddr(domain, chain) { const node = namehash(domain) const resolver = rns.resolver(node) if (!resolver.supportsInterface(&#39;0x8be4b5f6&#39;)) throw; return resolver.chainAddr(node, chain); }"
 },
 {
  "url": "/wallet/use/mycrypto/",
  "title": "MyCrypto",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/wallet/use/myetherwallet/",
  "title": "MyEtherWallet",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/architecture/rsk-registrar/other/nameprice/",
  "title": "Name Price",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "MainNet: 0xd09adf13e482928e47e96dd6f02aad1daf7a5a47 TestNet: 0x794f99f1a9382ba88b453ddb4bfa00acae8d50e8 Smart contract Determines the price of a domain. Years Price 1 2 RIF 2 4 RIF 2+k 4+k RIF Public methods price price function price (string calldata /*name*/, uint /*expires*/, uint duration) external view returns(uint); Calculate name price in RIF token for a given duration Is a pure function, but converted to view due the AbstractNamePrice spec. duration of the name to register in years Return price in RIF tokens."
 },
 {
  "url": "/wallet/use/nifty/",
  "title": "Nifty",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/guide/operations/",
  "title": "Operations - RNS User guide",
  "category": "",
  "tags": "rns, guide, rns-user-guide",
  "date": "",
  "desc": "How to login to your domain, extend your domain expiration time, transfer your domain, change the RSK address, add a cryptocurrency address, update a cryptocurrency address, delete a cryptocurrency address, activate multi chain functionality, create a subdomain, change a subdomain&#39;s owner, delete a subdomain"
 },
 {
  "url": "/libraries/web3/personal/",
  "title": "web3.personal",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/truffle-boxes/pet-shop-box/",
  "title": "Using Truffle Boxes with RSK",
  "category": "",
  "tags": "tutorial, rsk, truffle",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/ethereum-devs/port-ethereum-dapps/",
  "title": "Port Ethereum dApps",
  "category": "",
  "tags": "tutorial, rsk, ethereum dapps",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/lumino/node/protocol/",
  "title": "Protocol",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/marketplace/public-repos/",
  "title": "RIF Marketplace Public repositories",
  "category": "",
  "tags": "rif, marketplace, github, repositories",
  "date": "",
  "desc": "Check out our public repositories RIF Marketplace UI RIF Marketplace Cache RIF Marketplace NFTS Contract RIF Marketplace Dev Environment"
 },
 {
  "url": "/rif/lumino/public-repos/",
  "title": "Public repositories",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Check out our public repositories Lumino Node Lumino Web Lumino contracts Lumino Node SDK Lumino Explorer"
 },
 {
  "url": "/tutorials/quiz-app-to-dapp/",
  "title": "RSK Workshop: Quiz App to dApp",
  "category": "",
  "tags": "rsk, workshop, solidity, javascript, swarm",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/operations/register-auction-deprecated/",
  "title": "Register a domain - Deprecated",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "This contract has been deprecated. Please find the new registration process [here](Register-a-name). The process consists of two main phases: The auction phase The annual rent payment The auction phase Any user can start an auction for any available domain name. It is a public auction that respects the Vickrey auction principles. A Vickrey auction is a type of blind auction. Bidders submit written bids without knowing the bid of the other people in the auction. The highest bidder wins, but the price paid is the second-highest bid. The good obtained after the auction is a domain registered under the rsk top level domain in the RIF Name Service running on the RSK blockchain. The Vickrey auction process consists of 4 phases: Open: A domain’s default state. Any user can start an auction for any name that remains in Open state. This auction is also recorded in the blockchain, and can be accessed by any other user. Auction: Auction started. Any user can place a bid for the domain auctioned. This phase lasts 3 days…"
 },
 {
  "url": "/rif/rns/operations/register-subdomain/",
  "title": "Set subdomain owner",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "This operation can be performed for either register a new subdomain or change an existing subdomain’s owner. Go to RNS Manager Login with your domain Go to admin page In subdomains section, type the subdomain label you want to register/transfer Set the subdomain owner by clicking on edit"
 },
 {
  "url": "/rif/rns/operations/register/",
  "title": "Register a domain",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "The process consists of three main steps: Go to the RNS Manager. You need to check if your name is available. Search the name you want to register. If your name is available, click on “register your domain”, and go to the next step. Select the duration for which you would like to register your name and check that you have that amount of RIF Tokens Click on “Request to register”. Sign the transaction and wait for one minute. We’re almost done! After approximately one minute, the “Register” button will be enabled. Click on it! Find here all available features."
 },
 {
  "url": "/rif/rns/specs/registry/",
  "title": "RNS Specs - Registry",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "The registry contract provides a simple mapping between a domain and its resolver. Everything related to domain ownership is managed in this contract, including ownership transfer and sub-domain creation. Each registry entry refers to a resolver which handles the resolution between the name domain and the desired resource. The RNS Registry contract exposes functions for accessing data and functions to modify data: Access Ownership function owner(bytes32 node) constant returns (address); Returns the owner (registrar) of the specified node. Resolution function resolver(bytes32 node) constant returns (address); Returns the resolver for the specified node. Caching function ttl(bytes32 node) constant returns (uint64); Returns the time-to-live (TTL) of the node; that is, the maximum duration for which a node’s information may be cached. Modify Ownership function setOwner(bytes32 node, address owner); Transfers ownership of a node to another registrar. This function may only be called by the current owner of node. A successful call to this function logs the event Transfer(bytes32 indexed, address). function setSubnodeOwner(bytes32 node, bytes32 label, address owner); …"
 },
 {
  "url": "/rif/rns/architecture/registry/",
  "title": "Registry",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "The RNS Registry is the contract that stores the ownership of the nodes. Registry mainnet Address: 0xcb868aeabd31e2b66f74e9a55cf064abb31a4ad5 ABI: RNSABI.json See RNS Testnet section for testing environment information. Index Abstract Acquire a domain Set a subdomain Change the Resolver Transfer ownership Release a domain ownership Structure Methods owner setOwner setSubnodeOwner resolver setResolver ttl setTTL setDefaultResolver Abstract Node The node is the main structure of the RIF Name Service Registry. A node has an owner, a Resolver and a time to live (TTL). A node owner can: Register sub nodes derived from it, with their owners Set the node’s Resolver: Resolvers are responsible for performing resource lookups for a name - for instance, returning a contract address, a content hash, or IP address(es) as appropriate. Set the node’s TTL: the caching time-to-live. Transfer node’s ownership The root node The root node is the parent of top-level domains. This node is located in the &amp;lt;code…"
 },
 {
  "url": "/tutorials/ethereum-devs/remix-and-metamask-with-rsk-testnet/",
  "title": "Using Remix and Metamask with RSK testnet",
  "category": "",
  "tags": "tutorial, rsk, remix, metamask",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/operations/renew/",
  "title": "Renew a domain",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Don’t forget to migrate your name before renewing it! The renewal process is under development. Find the due date here."
 },
 {
  "url": "/rif/rns/architecture/rsk-registrar/renewers/renewer/",
  "title": "Renewer",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "RSK MainNet: 0x7a9872a7615c475b62a62b8f6e491077fb05f663 RSK TestNet: 0xe48ad1d5fbf61394b5a7d81ab2f36736a046657b Has renewer role in RSK Owner. Smart contract Accepts payments via ERC-20 approve() + register().3 ERC-721 transferAndCall().4 Calculates price using NamePrice contract. It has an owner that can2 change name price contract. Public methods price renew price function price (string memory name, uint expires, uint duration) public view returns(uint); Returns the price of a name in RIF name not used. Pass &#39;&#39; expires not used. Pass 0 duration to register the name for. renew function renew(string calldata name, uint duration) external; Renews a name in Node Owner. This method should be called if the domain is owned by someone. You must have previously executed approve() for the amount of tokens to be transferred. name The name to register. duration Time to register in years. Register via…"
 },
 {
  "url": "/tutorials/resolve-nifty-issue/",
  "title": "Resolve Nifty Wallet Issue",
  "category": "",
  "tags": "tutorial, nifty, chainId, address, derivation, bip44, slip44",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/operations/resolve/",
  "title": "Resolve a domain address",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "The Resolver contract handles the resolution between the name domain and the resource. Each Registry entry references a Resolver. To find a domain’s resolution: Go to RNS Manager resolution page Type the domain you want to resolve Resolve! &amp;lt;!– ## Libraries Resolution libraries are available for developers to integrate and resolve RNS domains and subdomains in their own applications, wallets, exchanges. ## Resolution process The resolution can be described in two steps: 1. Query the RNS to retrieve the domain’s resolver: js const name = &#39;satoshi.rsk&#39; const node = namehash() const resolverAddress = rns.resolver(node) if (resolverAddress == &#39;0x00&#39;) console.error(&#39;No resolver configured for &#39; + name) else console.log(&#39;Resolver address configure for &#39; + name + &#39; is &#39; + resolverAddress) Yielded address may be 0x00 if the Resolver is not configured or the domain node is not yet present in the Registry. 2. Finally resolve the domain through the addr getter from the Resolver: js const resolver = ResolverInterface.at(resolverAddress) const address = resolver.addr(node) if (address == &#39;0x00&#39;) console.error(&#39;The domain &#39; + name + &#39; does not resolve to any address!&#39;) else console.log(&quot;The domain &quot; + name +&quot; resolves to &quot; + address)…"
 },
 {
  "url": "/rif/rns/specs/resolvers/",
  "title": "RNS Specs - Resolvers",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Resolvers may implement any subset of the record types specified here. Where a record types specification requires a resolver to provide multiple functions, the resolver MUST implement either all or none of them. Resolvers MUST specify a fallback function that throws. Resolvers must implement ERC-165 interface detection standard. supportsInterface method must return if the interfaceID queried is simply equal to the signature hash of the function that resolves the desired resource record. Currently standardized resolver interfaces are specified below. Check out definitive resolver for implementation details. Contract address Provides the contract address for the specified domain. function addr(bytes32 node) returns (address); node: the namehash of the domain to query for. Returns the contract address of the specified domain. A zero address is returned if the node has no address specified. When updated emits event AddrChanged(bytes32 indexed node, address a); Interface ID: 0x3b3b57de Specification: EIP-137 Resolution protocol: Query the resolver address to the registry. Query addr to…"
 },
 {
  "url": "/rif/rns/integrate/reverse-resolution/",
  "title": "Reverse address resolution",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Finding the domain associated with an address consists of X steps: Obtain the identifier of the address reverse records. Generate the RNS domain for a given account’s reverse records. Convert the address to hexadecimal representation in lower-case, and append addr.reverse. For instance, the address 0x112234455c3a32fd11230c42e7bccd4a84e02010 might have its reverse records associated at 112234455c3a32fd11230c42e7bccd4a84e02010.addr.reverse. Use namehash algorithm with the reverse record domain to get the identifier of the address. Get its resolver contract. Use resolver(bytes32) Detect if contract supports name(bytes32) interface via ERC-165 interface detection. Use supportsInterface(bytes4) with interface ID: 0x691f3431 ERC-165 spec Query for name resolution. Use name(bytes32) with the domain identifier. name(bytes32) spec function reverseResolve (address) { const reverseName = `${address.slice(2).toLowerCase()}.addr.reverse`; const node = namehash(reverseName); const resolver = rns.resolver(node); const name = resolver.&amp;lt;span…"
 },
 {
  "url": "/rif/rns/integrate/rsk-address-resolution/",
  "title": "RSK Address Resolution guidelines",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Resolving an RSK address associated to a domain consist of 4 steps: Obtain the identifier of the domain. Use namehash algorithm Get the domain’s resolver contract. Use resolver(bytes32) Detect if contract supports addr(bytes32) interface via ERC-165 interface detection. Use supportsInterface(bytes4) with interface ID: 0x3b3b57de ERC-165 spec Query for address resolution. Use addr(bytes32) with the domain identifier. addr(bytes32) spec function getAddr(domain) { const node = namehash(domain) const resolver = rns.resolver(node) if (!resolver.supportsInterface(&#39;0x3b3b57de&#39;)) throw; return resolver.addr(node); }"
 },
 {
  "url": "/tutorials/rsk-api/",
  "title": "RSK API",
  "category": "",
  "tags": "tutorial, rsk, cli",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/truffle-boxes/rsk-next-box/",
  "title": "Truffle Box (rsk-next-box)",
  "category": "",
  "tags": "tutorial, rsk, truffle, next",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/truffle-boxes/rsk-react-box/",
  "title": "Truffle Box (rsk-react-box)",
  "category": "",
  "tags": "tutorial, rsk, truffle, react",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/truffle-boxes/rsk-react-express-box/",
  "title": "Truffle Box (rsk-react-express-box)",
  "category": "",
  "tags": "tutorial, rsk, truffle, react, express",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tools/truffle/boxes/rsk-starter-box/",
  "title": "RSK starter box",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/truffle-boxes/rsk-starter-box/",
  "title": "Using Truffle box rsk-starter-box",
  "category": "",
  "tags": "tutorial, rsk, truffle, truffle-box",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tools/explorer/rsk/",
  "title": "RSK",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/libraries/rsk3js/docs/rsk3-abi/",
  "title": "rsk3.js",
  "category": "",
  "tags": "libraries, rsk, rsk3js, javascript, web3js",
  "date": "",
  "desc": ""
 },
 {
  "url": "/libraries/rsk3js/docs/rsk3-account/",
  "title": "rsk3.js",
  "category": "",
  "tags": "libraries, rsk, rsk3js, javascript, web3js",
  "date": "",
  "desc": ""
 },
 {
  "url": "/libraries/rsk3js/docs/rsk3-contract/",
  "title": "rsk3.js",
  "category": "",
  "tags": "libraries, rsk, rsk3js, javascript, web3js",
  "date": "",
  "desc": ""
 },
 {
  "url": "/libraries/rsk3js/docs/rsk3-net/",
  "title": "rsk3.js",
  "category": "",
  "tags": "libraries, rsk, rsk3js, javascript, web3js",
  "date": "",
  "desc": ""
 },
 {
  "url": "/libraries/rsk3js/docs/rsk3-personal/",
  "title": "rsk3.js",
  "category": "",
  "tags": "libraries, rsk, rsk3js, javascript, web3js",
  "date": "",
  "desc": ""
 },
 {
  "url": "/libraries/rsk3js/docs/rsk3-react-native/",
  "title": "rsk3.js",
  "category": "",
  "tags": "libraries, rsk, rsk3js, javascript, web3js",
  "date": "",
  "desc": ""
 },
 {
  "url": "/libraries/rsk3js/docs/rsk3-utils/",
  "title": "rsk3.js",
  "category": "",
  "tags": "libraries, rsk, rsk3js, javascript, web3js",
  "date": "",
  "desc": ""
 },
 {
  "url": "/libraries/rsk3js/docs/rsk3/",
  "title": "rsk3.js",
  "category": "",
  "tags": "libraries, rsk, rsk3js, javascript, web3js",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/architecture/rsk-registrar/rskowner/",
  "title": "RSK Owner",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "RSK MainNet: 0x45d3e4fb311982a06ba52359d44cb4f5980e0ef1 RSK TestNet: 0xca0a477e19bac7e0e172ccfd2e3c28a7200bdb71 Smart contract Owner of rsk top level domain. It can setSubdomainOwner in RNS. It represents domain ownership implementing ERC-7211 non-fungible token standard. This standard provides basic functionality to track and transfer NFTs2. Stores domains’ expiration time. The expiration time determines whether a domain is owned or not. Determines if a domain is available to be purchased. Accepts domain ownership clamming from previous rsk registrar. Grants access to other contracts for registering new domains (registrar role)2. Grants access to other contracts for renewing domains (renewer role)2. Allows to reclaim ownership in RNS of owned domains. It has an owner that can2 Change rsk tld resolver and ttl. Add/remove registrar contracts. Add/remove renewer contracts. Implementation RSK Owner is an Ownable contract and represents domain labels ownership fully compatible with ERC-721 interface using OpenZeppelin’s implementation. The implementation is divided into two main parts: The public methods exposed by RSK Owner, and the restricted access methods to manage upgrades to the solution. The latter will not be described in this article. Public methods available ERC-721 &amp;lt;a…"
 },
 {
  "url": "/rif/rns/run-locally/",
  "title": "Run RNS locally",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "More information coming soon! Collaborate on Github"
 },
 {
  "url": "/rif/storage/providers/swarm/run/",
  "title": "Running Swarm for the first time",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "1. Check the swarm command is in the PATH Verify this with which swarm. If the swarm command cannot be found, you can add the Swarm binary route to your PATH for easier access. Alternatively, you will need to use $GOPATH/bin/swarm instead, assuming you are compiling directly from the source code. 2. Execute the swarm command To boot up Swarm for the first time simply execute: swarm 3. Specify a private key You will need a private key (sometimes referred to as account) to use Swarm. This can either: be specified by the bzzaccount flag (if the account already exists) be created through a Swarm prompt (if not specified) Note that after used once, an account will continue to be used by default if not specified the next time. 4. Verify the client is running If Swarm was started successfully, the local web server endpoint should be accessible through your browser, by default at http://localhost:8500. This web interface will allow you to upload and download files manually. In contrast, the terminal in which swarm was executed will allow…"
 },
 {
  "url": "/tutorials/send-tokens-through-metamask/",
  "title": "Send RIF Tokens through Metamask",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/operations/set-addr/",
  "title": "Set address resolution",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "This operation is used to set the address resolution of a domain. If you are using your domain to receive assets, you may use this guide to change the wallet address where you receive payments. Go to RNS Manager Login Go to admin page If you are using a standard resolver, an admin resolution button will appear. Click on it. Beside ‘addr’ click on edit an insert the desired address Click on set and you are done!"
 },
 {
  "url": "/rif/rns/operations/set-btc-address/",
  "title": "Set chain address resolution",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "This operation is used to set a chain address resolution of a domain. If you are using your domain to receive assets, you may use this guide to change the wallet address where you receive payments. Go to RNS Manager Login Go to admin page If you are using the multi chain resolver, an admin resolution button will appear. Click on it. If you are not using multi-chain resolver, follow these instructions. Select the chain you would like to update and click on edit Input the new address, click on edit and you are done!"
 },
 {
  "url": "/rif/rns/operations/set-resolver/",
  "title": "Set resolver",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "This operation is used to change the resource record types for a domain. Use this guide to set multi-chain resolver for your domain. Go to RNS Manager Login Go to admin page Click on edit beside resolver. Choose the resolver you want to set and click on edit."
 },
 {
  "url": "/rif/rns/operations/set-reverse/",
  "title": "Find the name of an address",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "This process describes how to expose a name for an owned address. This requires you have the keys to unlock the account. Go to RNS Manager Login Go to admin page Find the ‘set reverse’ button at the bottom of the page and click on it. Find my account’s name"
 },
 {
  "url": "/tutorials/ethereum-devs/setup-truffle-oz/",
  "title": "How to create a new project using Truffle and OpenZeppelin connected to RSK network",
  "category": "",
  "tags": "tutorial, rsk, openzeppelin, truffle",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/guide/setup/",
  "title": "Setup - RNS User guide",
  "category": "",
  "tags": "rns, guide, rns-user-guide",
  "date": "",
  "desc": "Compatible wallets, connect Nifty wallet to RSK, connect Metamask wallet to RSK, get RBTC, get RIF Tokens, display amount of tokens in the Nifty wallet, display amount of tokens in the Metamask wallet"
 },
 {
  "url": "/rif/marketplace/guide/setup/",
  "title": "Setup - RIF Marketplace User Guide",
  "category": "",
  "tags": "rif, marketplace, guide",
  "date": "",
  "desc": "RIF Marketplace User Guide"
 },
 {
  "url": "/webinars/202007-005/slides/",
  "title": "Testing Smart Contracts with Truffle",
  "category": "",
  "tags": "rsk, solidity, truffle, test, mocha, slides",
  "date": "",
  "desc": ""
 },
 {
  "url": "/webinars/202006-004/slides/",
  "title": "How to Upload a Website on RIF Storage",
  "category": "",
  "tags": "rif, swarm, dweb, slides",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/libs/smart-contracts/",
  "title": "Full smart contracts suite",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Import contracts using npm. Registry Abstract RNS Registry and a 0.5.0 implementation. Source: https://github.com/rnsdomains/rns-registry npm: https://www.npmjs.com/package/@rsksmart/rns-registry npm i @rsksmart/rns-registry Resolver Addr Resolver and Multi-chain resolver. Source: https://github.com/rnsdomains/rns-resolver npm: https://www.npmjs.com/package/@rsksmart/rns-resolver npm i @rsksmart/rns-resolver Reverse Reverse Registrar and Name Resolver. Source: https://github.com/rnsdomains/rns-reverse npm: https://www.npmjs.com/package/@rsksmart/rns-reverse npm i @rsksmart/rns-reverse ERC-677 Token ERC-677 Token contract implementation, compatible with RIF Token implementation. Use it for testing purposes. Source: https://github.com/rnsdomains/erc677 npm: https://www.npmjs.com/package/@rsksmart/erc677 npm i @rsksmart/erc677 Auction Registrar 0.5.0 implementation of RSK Auction Registrar (outdated). Source: https://github.com/rnsdomains/rns-auction-registrar npm: https://www.npmjs.com/package/@rsksmart/rns-auction-registrar npm i @rsksmart/rns-auction-registrar RSK Registrar Current RSK Registrar. Source: https://github.com/rnsdomains/rns-rskregistrar npm: https://www.npmjs.com/package/@rsksmart/rns-rskregistrar npm i @rsksmart/rns-rskregistrar Locally install full suite Run current architecture of RNS in a local network. Source: https://rsksmart.com/rsksmart/rns-full-suite git clone https://github.com/rsksmart/rns-full-suite.git cd rns-full-suite npm i truffle develop truffle(develop)&amp;gt; migrate"
 },
 {
  "url": "/develop/apps/tools/stats/",
  "title": "RSK Stats",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tools/stats/",
  "title": "RSK Stats",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/libs/rns-artifacts/resolver/string-resolver/",
  "title": "RNS Solidity artifacts - String Resolver",
  "category": "",
  "tags": "rns, artifacts, resolvers, string resolver",
  "date": "",
  "desc": "String Resolver provides an RNS domain of a string resolution. RSK Mainnet: 0x2e4ae4ce78261f0efd8d859cf54966d7b2a7ae11 RSK Testnet: 0xc980a15304b70a6a00ce8fd376e8ce78e15c5dd8 It provides two methods: function str(bytes32 node) external view returns (string memory) Returns the current str record for a domain. Params: node domain Returns: str record function setStr(bytes32 node, string calldata newStr) external onlyNodeOwner(node) Sets the str record for a domain. Params: node domain newStr record value Emits: event NewStr(bytes32 indexed node, string str)"
 },
 {
  "url": "/rif/marketplace/services/rnsdomains/techspecs/",
  "title": "RIF Marketplace RNS Tech Specs",
  "category": "",
  "tags": "rif, marketplace, rns, domains, technical",
  "date": "",
  "desc": "RIF Name Service (RNS) enables the use of human readable names for blockchain addresses helping users to receive transactions in personalized domains. The Name Services (RNS) Marketplace allows users to buy and sell RNS domains. Sellers can list their owned domains and set a listing price in RIF for each of them. Buyers can browse the available Domains and purchase the one they prefer by paying the listed price. ## User Flows * High-level use cases with operations within the RNS Marketplace* ### [Seller] Selling an RNS Domain 1. List an RNS Domain for sale by submitting two transactions. - Specify the price in RIF - (future) Specify payment currency among the options available. 2. Send approval Domain transfer transaction. (Transaction 1/2) 3. List in the Marketplace by submitting the Placement transaction. (Transaction 2/2) ### [Seller] Cancel a listed RNS Domain 1. Removing a listed RNS Domain from the Marketplace by submitting two transactions. 2. Send approval Domain transfer transaction. (Transaction 1/2) 3. Send the unplacement transaction to remove the Domain from the Marketplace. (Transaction 2/2) ### [Buyer] Buy an RNS Domain A Buyer can browse the available RNS Domains, filter based on the selected criteria and…"
 },
 {
  "url": "/rif/storage/providers/swarm/testnet-network/",
  "title": "Connecting to testnet Swarm network",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "What is the RIF Storage testnet The RIF Storage testnet allows developers and end-users to get a feeling with how it is to interact with a decentralized storage protocol. For now, RIF Storage is integrated with Swarm. On top of this, we are also integrating with IPFS (more to be announced soon!) and we are developing the specifications for the gateways, marketplaces and pinning services A crucial difference between the testnet, just launched by us, and the official Swarm testnet is the usage of the RIF Token to incentivize bandwidth accounting in the RIF Storage testnet. Ultimately, the vision of both Swarm and RIF is to support multiple currencies under the same network, but until that vision becomes a reality we want to give developers in the RIF ecosystem the opportunity to try out the user experience of RIF Storage, using the RIF (test) token. ## Hands-on Be one of the first to interact with the Swarm testnet and download a special surprise! ### Gateway TLDR; RIF Storage is operating a gateway service, so you can interact with Swarm without running the software yourself. Please navigate here and verify that you can upload a file and download it from…"
 },
 {
  "url": "/rif/rns/testnet/",
  "title": "RNS Testnet",
  "category": "",
  "tags": "rif, rns, testnet",
  "date": "",
  "desc": "Registartion flow Download a browser wallet. Recommended: Nifty Wallet Connect your wallet to RSK Testnet. You can do it with the top left selector on Nifty Wallet. (optional) List tRIF token balance using this address: 0x19F64674D8A5B4E652319F5e239eFd3bc969A1fE. In Nifty wallet do this in Tokens tab. Browse to RSK faucet to get some gas. Browse to tRIF faucet to get some test RIF tokens. Browse to RNS Testnet Manager and search for your desired domain. Follow the registration process. Smart contracts RNS 0x7d284aaac6e925aad802a53c0c69efe3764597b8 Resolver 0x25C289ccCFFf700c6a38722F4913924fE504De0e RSK Registrar RSKOwner: 0xca0a477e19bac7e0e172ccfd2e3c28a7200bdb71 FIFSRegistrar: 0x36ffda909f941950a552011f2c50569fda14a169 FIFSAddrRegistrar: 0x90734bd6bf96250a7b262e2bc34284b0d47c1e8d Renewer: 0xe48ad1d5fbf61394b5a7d81ab2f36736a046657b NamePrice: 0x794f99f1a9382ba88b453ddb4bfa00acae8d50e8 BytesUtils: 0x7faf084ef72cb71f3383a5c568c70853ac4c298e Reverse ReverseRegistrar:0xc1cb803d5169e0a9894bf0f8dcdf83090999842a NameResolver: 0x8587385ad60038bB181aFfDF687c4D1B80C4787e RSK Registrar legacy TokenRegistrar (auction): 0x3d1a11c623bd21375f2b69f4eec814f4ceeb1d8d Legacy Resolvers Public Resolver: 0x1e7ae43e3503efb886104ace36051ea72b301cdf MultiChain Resolver: 0x404308f2a2eec2cdc3cb53d7d295af11c903414e RNS Manager testnet.manager.rns.rifos.org"
 },
 {
  "url": "/rif/marketplace/testnet/",
  "title": "RIF Marketplace Testnet",
  "category": "",
  "tags": "rif, marketplace, testnet",
  "date": "",
  "desc": "Wallet Setup Download a browser wallet. Recommended: Nifty Wallet Connect your wallet to RSK Testnet. You can do it with the top left selector on Nifty Wallet. (optional) List tRIF token balance using this address: 0x19F64674D8A5B4E652319F5e239eFd3bc969A1fE. In Nifty wallet do this in Tokens tab. Browse to RSK faucet to get some gas. Browse to tRIF faucet to get some test RIF tokens. Browse to RIF Marketplace - Testnet to access the available services. Smart contracts Name Services (NFTs Marketplace Contract) RNS Domains Buy/Sell Contract: 0x5a2E616F64923AeF99E871EE6F80b9A00CCD6316 RNS Manager (to register and manage RNS Domains) testnet.manager.rns.rifos.org"
 },
 {
  "url": "/rif/token/",
  "title": "RIF Token",
  "category": "",
  "tags": "rif, token, erc677",
  "date": "",
  "desc": "Information about the RIF token, where to obtain it, how to transfer it, and technical details on its token standard"
 },
 {
  "url": "/rif/rns/operations/transfer/",
  "title": "Renew a domain",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Under development."
 },
 {
  "url": "/tutorials/ethereum-devs/truffle-test/",
  "title": "Testing smart contracts using Truffle",
  "category": "",
  "tags": "tutorial, rsk, truffle, test",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/try-rns/",
  "title": "Try RNS",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "More information coming soon! Collaborate on Github"
 },
 {
  "url": "/rif/lumino/node/install/ubuntu/",
  "title": "Get your own RIF Lumino node up and running on Ubuntu",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Prerequisites 1. Access to a synched RSK node. You can do this in a variety of ways: * Public nodes * Run your own node on Testnet or Mainnet * Compile and run a RSK node locally 1. An RSK account with an R-BTC balance NOT lower than 0.001 R-BTC 1. Ubuntu 18.04+ ## Install required libraries/software ### Install Python 3.7 Update your packages and install pre-requisites: bash sudo apt update sudo apt install software-properties-common Add deadsnakes PPA to your sources list: bash sudo add-apt-repository ppa:deadsnakes/ppa Once the repository is enabled install Python 3.7: bash sudo apt install python3.7 ### Install Python 3.7-dev If you didn’t update your local APT repository: bash sudo apt update To install python 3.7-dev run the following command: bash sudo apt-get install libpq-dev python3.7-dev ### Install PIP If you didn’t update your local APT repository: bash sudo apt update Install pip3: bash sudo apt-get install python3-pip ### Install virtualenv If you didn’t update your local APT repository: bash sudo apt update Install virtualenv: bash sudo apt-get install virtualenv ## Build RIF Lumino from code 1. Get the code from https://github.com/rsksmart/lumino/releases/tag/0.0.2 2. Uncompress the downloaded file…"
 },
 {
  "url": "/rif/lumino/node/use/",
  "title": "How To Use",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "How to build and run a Lumino node. How to use its user interface to view dashboard, quick payments, token view, send tokens, pay, deposit, close channels, and view payments"
 },
 {
  "url": "/tutorials/using-blockmason/",
  "title": "Blockmason",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tools/tokenbridge/usingmycrypto/",
  "title": "Interaction guide using MyCrypto",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/rif/rns/guide/value-proposition/wallets/",
  "title": "Full Integration Guide and Value proposition of RNS for Wallets",
  "category": "",
  "tags": "rns, guide, wallets, value",
  "date": "",
  "desc": "Phase 1: Problems to solve, UX proposal, Send BTC example, Feature summary, RNS Integration guidelines. Phase 2:  Problems to solve, Feature summary"
 },
 {
  "url": "/rif/lumino/explorer/own/web/",
  "title": "Lumino Explorer WEB",
  "category": "",
  "tags": "",
  "date": "",
  "desc": "Pre requisites 1. Lumino Explorer Api Running 2. Yarn (Latest Version) ## Build RIF Lumino Explorer WEB from code 1. Get the [RELEASE.NUMBER] code from [GITHUB.URL] 2. Go to the path you downloaded or cloned Lumino’s code (lets call this path $RIF_LUMINO_EXPLORER_WEB_PATH) bash yarn install ## Start your RIF Lumino Explorer WEB 1. Go to $RIF_LUMINO_EXPLORER_WEB_PATH 2. Run the following command: RIF_LUMINO_EXPLORER_WEB_PATH=$YOUR_LUIMNO_API_HOST_AND_PORT yarn start &amp;lt;table class=&quot;table&quot;&amp;gt; &amp;lt;thead&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th scope=&quot;col&quot;&amp;gt;FIELD&amp;lt;/th&amp;gt; &amp;lt;th scope=&quot;col&quot;&amp;gt;DESCRIPTION&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/thead&amp;gt; &amp;lt;tbody&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td scope=&quot;row&quot;&amp;gt;$YOUR_LUIMNO_API_HOST_AND_PORT&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt; If this parameter is not present, the value that the application will take to invoke services to the api explorer will be http://localhost:8080 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/tbody&amp;gt; &amp;lt;/table&amp;gt; After you run yarn command, you will be presented with the following message: bash yarn run $YOUR_YARN_VERSION $ react-scripts start Starting the development server... Compiled successfully! You can now view RIF-Lumino in the browser. Local: http://localhost:3000/ On Your Network: http://$YOUR_PUBLIC_IP_MACHINE:3000/ Note that the development build is not optimized. To create a production build, use yarn build. ## Additional help The following sections are created using an Ubuntu 18.04.2 LTS ### Install Yarn Download: https://yarnpkg.com/en/docs/install#debian-stable) You will first need to configure the repository: ``` curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key…"
 },
 {
  "url": "/tutorials/workshop-js-testing/",
  "title": "RSK Workshop: Javascript Testing",
  "category": "",
  "tags": "rsk, workshop, javascript, testing, mocha",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/workshop-prereqs/",
  "title": "RSK Workshop: Pre-requisites",
  "category": "",
  "tags": "rsk, workshop, pre-requisites",
  "date": "",
  "desc": ""
 },
 {
  "url": "/tutorials/workshop-smart-contract-testing-truffle/",
  "title": "RSK Workshop: Smart Contract Testing using Truffle",
  "category": "",
  "tags": "rsk, workshop, solidity, testing, truffle",
  "date": "",
  "desc": ""
 },
 {
  "url": "/feed.xml",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/sitemap.xml",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/robots.txt",
  "title": "",
  "category": "",
  "tags": "",
  "date": "",
  "desc": ""
 },
 {
  "url": "/quick-start/step1-install-rsk-local-node/",
  "title": "Quick Start - Step 1",
  "category": "",
  "tags": "quick-start,, rskj",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "quick start - install RSK local node - prep environment, verify and install RSKj"
 },
 {
  "url": "/quick-start/step2-install-truffle-and-ganache/",
  "title": "Quick Start - Step 2",
  "category": "",
  "tags": "quick-start,, truffle,, ganache",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "quick start - tutorial project, install truffle, install ganache"
 },
 {
  "url": "/quick-start/step3-edit-smart-contract/",
  "title": "Quick Start - Step 3",
  "category": "",
  "tags": "quick-start,, solidity",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "quick start - smart contracts, solidity"
 },
 {
  "url": "/quick-start/step4-compile-and-deploy/",
  "title": "Quick Start - Step 4",
  "category": "",
  "tags": "quick-start,, compile,, deploy,, regtest,, truffle",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "quick start - compile smart contracts, deploy smart contracts to regtest"
 },
 {
  "url": "/quick-start/step5-run-smart-contract/",
  "title": "Quick Start - Step 5",
  "category": "",
  "tags": "quick-start,, smart-contract,, truffle,, web3",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "quick start - smart contract interactions through web3 REPL"
 },
 {
  "url": "/rsk/",
  "title": "RSK Blockchain",
  "category": "",
  "tags": "rsk",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "What is RSK?"
 },
 {
  "url": "/rsk/node/",
  "title": "Node (RSKj)",
  "category": "",
  "tags": "rsk,, rskj,, node",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Learn more about RSKj, a node implementation for the RSK blockchain"
 },
 {
  "url": "/rsk/node/architecture/",
  "title": "Architecture",
  "category": "",
  "tags": "rsk,, rskj,, node,, architecture",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Architecture of RSK nodes: JSON-RPC, Web3, and storage."
 },
 {
  "url": "/rsk/node/architecture/json-rpc/",
  "title": "JSON-RPC",
  "category": "",
  "tags": "rsk,, rskj,, node,, rpc",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "The JSON-RPC methods supported by RSK nodes."
 },
 {
  "url": "/rsk/public-nodes/",
  "title": "Using RSK Public Nodes (Mainnet &amp; Testnet) provided by IOVLabs",
  "category": "",
  "tags": "rsk,, networks,, versions,, rpc,, mainnet,, testnet,, cUrl",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "RSK Nodes: Public nodes (Mainnet, Testnet), Versioning, RPC Methods, and cUrl example"
 },
 {
  "url": "/rsk/node/install/",
  "title": "Install",
  "category": "",
  "tags": "",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Ensure that your system meets the minimum requirements before installing the RSK nodes on it. Install RSK Node and Join the RSK Papyrus Mainnet RSK nodes can be installed on all major platforms, including Linux, Windows, and Mac. Here we provide step-by-step instructions for all supported platforms. Depending on your network performance, it usually takes 10 to 15 mins to setup a working node on Mainnet. Supported Systems and Methods Type Platform Supported Methods Local Linux Ubuntu Package, CentOS, Fat JAR, Docker Local Mac Fat JAR, Docker Local Windows Fat JAR, Docker Cloud AWS AWS AMI, Ubuntu Package, Docker Cloud Azure Azure VM Image, Ubuntu Package, Docker Cloud Google Ubuntu Package, Fat JAR, Docker Using Ubuntu Package Visit Setup…"
 },
 {
  "url": "/rsk/node/install/requirements/",
  "title": "Hardware requirements",
  "category": "",
  "tags": "hardware,, specs,, requirements",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Minimum hardware requirements for RSK"
 },
 {
  "url": "/rsk/node/install/docker/",
  "title": "Setup node on Docker",
  "category": "",
  "tags": "",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Make sure your system meets the minimum requirements before installing RSK nodes on it. Install Docker Desktop Client Docker Desktop provides an easy and fast way for running containerized applications on various of operating systems. For Mac OSX and Windows: Download and install Start the Docker Desktop client Login with a Docker Hub free account For Linux: Install Docker Engine Community Note that you will need to use sudo for all docker commands, by default. To avoid this additional steps are required. Ensure that docker is running by running the following command - it should run without any errors. docker ps More information about Docker install here. Install RSKj Using Docker First of all, download the RSK a Dockerfile and supervisord.conf from artifacts repo. Inside the artifacts repo, you can choose which type of node you are going to install: A node connected to the public RSK Mainnet: Dockerfile.MainNet A node connected to the public RSK Testnet: Dockerfile.TestNet A node connected to a private RegTest network: Dockerfile.RegTest Install the node using Docker containers Then build the…"
 },
 {
  "url": "/rsk/node/install/ubuntu/",
  "title": "Setup node on Ubuntu",
  "category": "",
  "tags": "",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Make sure your system meets the minimum requirements before installing RSK nodes on it. Install via Ubuntu Package Manager The easiest way to install and run a RSK node on Ubuntu is to do it through Ubuntu Package Manager. Type the commands below to install RSKj on Ubuntu using our PPAs for Ubuntu. The installed repo public key Fingerprint is 5EED 9995 C84A 49BC 02D4 F507 DF10 691F 518C 7BEA. Also, the public key could be found in document Ubuntu Key Server. $ sudo add-apt-repository ppa:rsksmart/rskj $ sudo apt-get update $ sudo apt-get install rskj During the installation, you will be asked to accept the terms and confirm the network. Choose Yes and Enter to accept the license to continue Choose mainnet and press Enter to continue Install via Direct Downloads You can also download the RSKj Ubuntu Package for Papyrus 2.0.1 and install it with the dpkg command. Follow this download link to download the matching package for your ubuntu system. #…"
 },
 {
  "url": "/rsk/node/install/centos/",
  "title": "Setup node on CentOS",
  "category": "",
  "tags": "",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "How to install and run an RSK node on CentOS"
 },
 {
  "url": "/rsk/node/install/java/",
  "title": "Setup node on Java",
  "category": "",
  "tags": "",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Make sure your system meets the minimum requirements before installing RSK nodes on it. You also need to install Java 8 JDK. Install the node using a JAR file The Fat JAR or Uber JAR can be downloaded or compiled (in a reproducible way or not). To run the node: Linux, Mac OSX $ java -cp &amp;lt;PATH-TO-THE-RSKJ-JAR&amp;gt; co.rsk.Start Windows C:&amp;gt; java -cp &amp;lt;PATH-TO-THE-RSKJ-JAR&amp;gt; co.rsk.Start Replace &amp;lt;PATH-TO-THE-RSKJ-JAR&amp;gt; with your path to the JAR file. As an example: C:/RskjCode/rskj-core-2.0.1-PAPYRUS-all.jar Using import sync Note: This feature is optional. Note: This feature, first released as part of RSKj v2.0.1, is currently experimental. If you don’t want to synchronize your node in the default way, you can use the import sync feature. This method imports a synchronized database from a trusted origin in a fraction of the time currently required. Use this command to run the node: Linux, Mac OSX $ java -cp &amp;lt;PATH-TO-THE-RSKJ-JAR&amp;gt; co.rsk.Start --import Windows C:&amp;gt; java -cp…"
 },
 {
  "url": "/rsk/node/install/azure/",
  "title": "Setup node on Azure",
  "category": "",
  "tags": "",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Install RskJ Using Azure Follow the instructions below to install and run an RSK node in Azure. By default, the node connects to Mainnet. If you want to change the network read this section. If you want to change some configuration, please refer to our RSK node configuration section. Also you can enable RPC calls to interact with the node (by default it’s disabled). Install The Node Using Azure On Azure, create a resource. Search for RSK, choose the node’s version and click Create. You will see 4 steps after deploying the node: Basics: complete this step with your information. Choose a name for the node, user name, password, subscription and resource group. Size: select your VM options. Check recommended minimum requirements. Settings: configure optional features. Summary: review the summary of what you have set and press Create. Wait for Azure to finish the deployment. Initialize RSK node configuration file settings (you can do it while switching network). Connect your computer to the node using bash. Edit configuration file using vi: &amp;lt;div class=&quot;language-shell…"
 },
 {
  "url": "/rsk/node/install/aws/",
  "title": "Setup node on AWS",
  "category": "",
  "tags": "",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Step 1: Navigate to the AWS Console site: https://console.aws.amazon.com Step 2: On the AWS services dashboard, click on EC2 (Virtual Machines), then on “launch instance” button. Step 3: Click on AWS Marketplace, search for “rsk”, and select the “RSK Node Bamboo v0.x.x MainNet”; Review the prices and select “Continue”. Step 4: Select the instance type. The once disabled doesn’t reach the minimum hardware requirements. Then, click on “Next: configure instance details” Step 5: Optionally change the default values on this screen, and continue clicking on “Next: Add Storage” Step 6: In the Storage section, increase the size to any size that is 50GB or higher, the minimum recommended to run the node, then click on “Next: Add Tags” Step 7: Optionally add a tag to identify the instance, then, click on “Next: Configure Security Group” Step 8: Now create a new rule with the TCP 22 port, and select a source to open the SSH port and be able to connect to the node remotely, then click on “Review and Launch” Step 9: Review the info…"
 },
 {
  "url": "/rsk/node/configure/",
  "title": "Configure",
  "category": "",
  "tags": "rsk,, rskj,, node,, config",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Setting your own config preferences, when using the Java command, Ubuntu, Azure, AWS, or Docker"
 },
 {
  "url": "/rsk/node/configure/reference/",
  "title": "Configuration reference",
  "category": "",
  "tags": "rsk,, rskj,, node,, config",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Configuration reference for RSKj"
 },
 {
  "url": "/rsk/node/configure/verbosity/",
  "title": "Configure Verbosity",
  "category": "",
  "tags": "rsk,, rskj,, node,, config,, logs",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Configure RSKj for desired log verbosity, finding log files, and using logback."
 },
 {
  "url": "/rsk/node/configure/switch-network/",
  "title": "Switch network",
  "category": "",
  "tags": "rsk,, rskj,, node,, config,, network,, mainnet,, testnet,, regtest",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "How to switch your RSK node between the Mainnet, Testnet, and RegTest networks"
 },
 {
  "url": "/rsk/node/configure/for-mining/",
  "title": "Configure RSKj node for mining",
  "category": "",
  "tags": "rsk,, rskj,, node,, config,, mining",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "How to run RSKj in a manner suited for mining."
 },
 {
  "url": "/rsk/node/contribute/",
  "title": "Contribute",
  "category": "",
  "tags": "rsk,, rskj,, node,, contribute",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Getting set up with RSKj and contributing towards its development."
 },
 {
  "url": "/rsk/node/reproducible/",
  "title": "Reproducible Build",
  "category": "",
  "tags": "rsk,, node,, compile,, reproducible,, checksum",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "A deterministic build process used to build RSK node JAR file. Provides a way to be reasonable sure that the JAR is built from GitHub RskJ repository. Makes sure that the same tested dependencies are used and statically built into the executable."
 },
 {
  "url": "/rsk/node/security-chain/",
  "title": "Ensure security chain of RskJ source code",
  "category": "",
  "tags": "rsk,, rskj,, node,, security,, verification",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "All the different ways that you can verify RSKj: Release signing key, fingerprint of the public key, SHA256SUMS.asc, binary dependencies, secure environment script"
 },
 {
  "url": "/rsk/node/contribute/cli/",
  "title": "CLI",
  "category": "",
  "tags": "rsk,, rskj,, node,, contribute,, cli",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "How to compile and run an RSKj node from the command line interface."
 },
 {
  "url": "/rsk/node/contribute/linux/",
  "title": "Linux",
  "category": "",
  "tags": "rsk,, rskj,, node,, contribute,, linux",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "How to compile and run an RSKj node on Linux. Installing pre-requisites. Get source code. Ensure security chain. Get external dependencies. Compile and run. Configuring your IDE."
 },
 {
  "url": "/rsk/node/contribute/macos/",
  "title": "Mac OSX",
  "category": "",
  "tags": "rsk,, rskj,, node,, contribute,, mac,, osx",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "How to compile and run an RSKj node on Mac OSX. Installing pre-requisites. Get source code. Ensure security chain. Get external dependencies. Compile and run. Configuring your IDE."
 },
 {
  "url": "/rsk/node/contribute/windows/",
  "title": "Windows",
  "category": "",
  "tags": "rsk,, rskj,, node,, contribute,, windows",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "How to compile and run an RSKj node on Windows. Installing pre-requisites. Get source code. Ensure security chain. Get external dependencies. Compile and run. Configuring your IDE."
 },
 {
  "url": "/rsk/node/troubleshooting/",
  "title": "Troubleshooting",
  "category": "",
  "tags": "rsk,, rskj,, node,, faq,, troubleshoot",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "How to solve some known or frequently encountered issues when working with RskJ"
 },
 {
  "url": "/rsk/rbtc/",
  "title": "R-BTC Token",
  "category": "",
  "tags": "",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "The Smart Bitcoin (R-BTC) is the token used to pay for the execution of transactions in RSK. You can convert BTC into R-BTC by sending BTC through the 2-way peg (both in Testnet and Mainnet), or by using the faucet in Testnet, or exchanges in Mainnet. R-BTC (Smart Bitcoin in Mainnet) Token Name R-BTC Total Supply 21,000,000 R-BTC Circulating supply API Contract Type Native (Bridge contract) How to get Exchanges 2-way peg Logo R-BTC-logo.png tR-BTC (Smart Bitcoin in Testnet) Token Name tR-BTC Total Supply 21,000,000 tR-BTC Circulating supply API Contract Type Native (Bridge contract) How to get Faucet 2-way peg Exchanges …"
 },
 {
  "url": "/rsk/rbtc/conversion/",
  "title": "BTC to R-BTC Conversion",
  "category": "",
  "tags": "rsk,, rbtc,, conversion,, peg,, 2-way,, peg-in,, peg-out,, federation",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Converting R-BTC to BTC (peg-in) and BTC to R-BTC (peg-out), for both Mainnet and Testnet."
 },
 {
  "url": "/rsk/rbtc/conversion/networks/mainnet/",
  "title": "Mainnet Guide",
  "category": "",
  "tags": "rsk,, rbtc,, conversion,, peg,, 2-way,, peg-in,, peg-out,, federation",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Converting BTC to R-BTC (peg-in) and R-BTC to BTC (peg-out)."
 },
 {
  "url": "/rsk/rbtc/conversion/networks/testnet/",
  "title": "Tesnet Guide",
  "category": "",
  "tags": "rsk,, rbtc,, conversion,, peg,, 2-way,, peg-in,, peg-out,, federation",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Converting t-BTC to tR-BTC (peg-in) and tR-BTC to t-BTC (peg-out)."
 },
 {
  "url": "/rsk/rbtc/conversion/with-ledger/",
  "title": "Conversion using a Ledger hardware wallet",
  "category": "",
  "tags": "rsk,, rbtc,, conversion,, peg,, 2-way,, peg-in,, peg-out,, federation,, ledger",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "How to perform the 2-way peg mechanism using Ledger"
 },
 {
  "url": "/rsk/rbtc/conversion/with-node-and-console/",
  "title": "Conversion with node and console",
  "category": "",
  "tags": "rsk,, rbtc,, conversion,, peg,, 2-way,, peg-in,, peg-out,, federation,, node,, cli",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "How to perform the 2-way peg mechanism using node and console"
 },
 {
  "url": "/rsk/rbtc/gas/",
  "title": "Gas",
  "category": "",
  "tags": "",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Gas is the internal pricing for running a transaction or contract. When you send tokens, interact with a contract, send R-BTC, or do anything else on the blockchain, you must pay for that computation. That payment is calculated as gas. In RSK this is paid in R-BTC. What is gas? How do I choose an appropriate gas price and limit? What happens if my transaction fails? What happens if I run out of gas? Gas in smart contracts What is gas? There are four important concepts: Gas price: The cost of the operation. Gas limit: The maximum gas the operation can afford. It’s an upper limit the user sets to prevent losing gas. Total gas: The gas the operation consumed. Also referred to as gas used. Unit: Gas is paid in R-BTC. Let’s start with a simple analogy: A car. To drive a car you need gas. Gas price is the money you pay for each gallon. Gas limit is the max amount of gas you accept to consume, the gas you charge. The total gas is the amount you’ve spent at the end of the trip. You can…"
 },
 {
  "url": "/rsk/architecture/turing-complete/",
  "title": "Turing complete",
  "category": "",
  "tags": "rsk,, rvm,, evm,, virtual, machine",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "The RSK virtual machine is compatible with Ethereum Virtual machine at an opcode level."
 },
 {
  "url": "/rsk/architecture/account-based/",
  "title": "Account Based RSK Addresses",
  "category": "",
  "tags": "rsk,, checksum,, chainId,, address,, derivation,, eip1191,, eip155,, bip44,, slip44",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "EIP-1191 chainId is used in RSK addresses as a checksum. m/44&#39;/137&#39;/0&#39;/0 is the derivation path used for BIP-44 compatible wallets."
 },
 {
  "url": "/rsk/architecture/2-way-peg/",
  "title": "2-way peg",
  "category": "",
  "tags": "rsk,, rbtc,, btc,, peg",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Transfer BTC to R-BTC, and R-BTC to BTC through a 2-way peg."
 },
 {
  "url": "/rsk/architecture/mining/",
  "title": "Merged Mining",
  "category": "",
  "tags": "rsk,, mining,, bitcoin,, pow",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "How merge mining RSK with Bitcoin works, and its benefits"
 },
 {
  "url": "/rsk/architecture/mining/implementation-guide/",
  "title": "Implementation Guide",
  "category": "",
  "tags": "rsk,, mining,, bitcoin,, pool",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "How to merge mine RSK using Bitcoin mining pool software"
 },
 {
  "url": "/rsk/architecture/mining/reference/",
  "title": "Merged mining reference",
  "category": "",
  "tags": "rsk,, mining,, bitcoin",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "How RSK leverages the Bitcoin network&#39;s consensus mechanism for its own secruity, and adds additional features to prevent double spending"
 },
 {
  "url": "/rsk/architecture/mining/remasc/",
  "title": "REMASC",
  "category": "",
  "tags": "rsk,, mining,, bitcoin,, remasc",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Reward Manager Smart Contract (REMASC) is a pre-compiled smart-contract that is executed on every block and has the responsibility to fairly distribute rewards collected from transaction fees into several participants of the network. However the distribution of rewards of a block is only performed once the block reaches a certain maturity. In other words, the rewards are paid only after a fixed number of blocks have confirmed a block. With the exception of the first blocks in the blockchain after genesis, every time a block is added to the blockchain, another previous block reaches maturity and its rewards are paid. REMASC is an implementation of DECOR+ [1] How it Works The REMASC contract maintains different internal accounts. One of these internal accounts is called Reward Balance. The Reward Balance always exists and its value can change when a new block is processed because of any of the following reasons: The block was accepted on the mainchain and all its transaction fees are added to the Reward balance. Miners and other rewarded parties get paid their reward and the rewarded value is subtracted from the Reward balance. As an example, let’s assume that a block has 2…"
 },
 {
  "url": "/rsk/architecture/security/",
  "title": "Security model",
  "category": "",
  "tags": "rsk,, security,, peg,, federation",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Achieving security in a 2-way pegged sidechain using proofs of payment"
 },
 {
  "url": "/rsk/architecture/privacy/",
  "title": "Transaction Privacy",
  "category": "",
  "tags": "rsk,, privacy,, anonymous,, pseudonymous",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Transaction pseudonymity vs transaction anonymity"
 },
 {
  "url": "/rsk/architecture/fast-payments/",
  "title": "Fast payments",
  "category": "",
  "tags": "rsk,, remasc,, interval,, speed,, propagation",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "Achieving faster on-chain block intervals"
 },
 {
  "url": "/rsk/node/architecture/logs/",
  "title": "Logs",
  "category": "",
  "tags": "",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": ""
 },
 {
  "url": "/rsk/node/architecture/peer-discovery/",
  "title": "Peer Discovery",
  "category": "",
  "tags": "",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": ""
 },
 {
  "url": "/rsk/node/architecture/storage/",
  "title": "Storage",
  "category": "",
  "tags": "",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": ""
 },
 {
  "url": "/rsk/node/contribute/network-upgrade/",
  "title": "Network Upgrades",
  "category": "",
  "tags": "rsk,, rskj,, node,, contribute,, upgrade,, protocol,, consensus,, rskip.",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "How to introduce consensus rules changes using network upgrades on an RSK node. What to consider. Adding a new rule. Runnign tests with new rules."
 },
 {
  "url": "/rsk/node/update/",
  "title": "RSK Node Updates",
  "category": "",
  "tags": "rsk,, rskj,, node,, update,, version",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": "How update RskJ, the RSK node, to a newer version, and verify that it works correctly. Also sign up for updates to get notified when there is a new version released."
 },
 {
  "url": "/rsk/rbtc/differences-with-ethereum/",
  "title": "Differences with ethereum",
  "category": "",
  "tags": "",
  "date": "2020-07-30 05:58:32 +0000",
  "desc": ""
 }
]